<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>duya10 的博客</title><link>http://example.org/</link><description>基于 Hugo 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>duya10@yandex.com (duya10)</managingEditor><webMaster>duya10@yandex.com (duya10)</webMaster><lastBuildDate>Tue, 09 Jul 2019 14:30:17 +0800</lastBuildDate><atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml"/><item><title>GDB 调试</title><link>http://example.org/gdb/</link><pubDate>Tue, 09 Jul 2019 14:30:17 +0800</pubDate><author>作者</author><guid>http://example.org/gdb/</guid><description>开启core，采集程序崩溃的状态 在 /etc/profile 最后一行添加内容，设置全局开启 croe 文件调试，大小不限，然后立即生效 1 2 3 4 5 6 vi /etc/profile # No core files by default 0, unlimited is oo ulimit -S</description></item><item><title>GCC 命令</title><link>http://example.org/gcc/</link><pubDate>Mon, 08 Jul 2019 14:30:11 +0800</pubDate><author>作者</author><guid>http://example.org/gcc/</guid><description>gcc 编译流程 GCC 编译器编译一个 C 语言程序分为四个阶段： 预处理阶段（Pre-Processing）：将头文件内容添加到程序里面，生成 .i 文件 编译阶段</description></item><item><title>Lua API</title><link>http://example.org/lua_api/</link><pubDate>Tue, 02 Jul 2019 14:30:06 +0800</pubDate><author>作者</author><guid>http://example.org/lua_api/</guid><description>gcc 命令 编译使用 lua api 的 c 语言程序 gcc temp.c -o temp -llua -lm -ldl 生成动态链接库供 lua 程序调用 gcc temp.c -o temp.so -fPIV -shared LUA_API 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26</description></item><item><title>理解字节序，大端和小端</title><link>http://example.org/bytecode/</link><pubDate>Tue, 14 May 2019 14:29:57 +0800</pubDate><author>作者</author><guid>http://example.org/bytecode/</guid><description>字节序 大端和小端 计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。 数值 0x2211 使用两个字节</description></item><item><title>MongoDB 笔记</title><link>http://example.org/mongodb/</link><pubDate>Fri, 10 May 2019 14:29:27 +0800</pubDate><author>作者</author><guid>http://example.org/mongodb/</guid><description><![CDATA[更新 update update 是更新操作，没有返回值 1 2 3 4 5 6 7 8 9 db.collection.update( &lt;query&gt;, &lt;update&gt;, { upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; } ) 参数说明： query : update 的查询条件，类似 sql update 查询内 where 后面的 update : update 的对象和一些]]></description></item><item><title>C 笔记</title><link>http://example.org/c_mark/</link><pubDate>Fri, 19 Apr 2019 14:29:21 +0800</pubDate><author>作者</author><guid>http://example.org/c_mark/</guid><description>指针 有效的指针运算 相同类型指针之间的赋值运算 指针同整数之间的加减运算 指向相同数组中元素的两个指针间的减法或比较运算（相减得到二者之间的元素个</description></item><item><title>原码、反码和补码</title><link>http://example.org/complement_code/</link><pubDate>Wed, 10 Apr 2019 14:29:14 +0800</pubDate><author>作者</author><guid>http://example.org/complement_code/</guid><description>原码、反码和补码 我们以八位的二进制示例 机器数和真值 一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的</description></item><item><title>Go mod 和 goproxy</title><link>http://example.org/gomod_goproxy/</link><pubDate>Fri, 29 Mar 2019 14:29:02 +0800</pubDate><author>作者</author><guid>http://example.org/gomod_goproxy/</guid><description>go module Go 1.11 版本发布之后，官方引入了 go module 来解决依赖管理的问题，go module 被集成到原生的 go cmd 中。 go modules wiki 使用 Go Module 深入浅出Go Modules goproxy Go 1.00 版本还新增了 GOPROXY 环境变</description></item><item><title>Go 进阶</title><link>http://example.org/go_advanced/</link><pubDate>Fri, 22 Mar 2019 14:28:52 +0800</pubDate><author>作者</author><guid>http://example.org/go_advanced/</guid><description>陷阱 引用和指针 silce, map, channel 是引用，内部数据结构包含了底层数据结构的指针，所以作为函数参数在函数中改变其中的值能够生效。 其余数据类型在作为函数参数时</description></item><item><title>面向对象理解</title><link>http://example.org/object_oriented/</link><pubDate>Thu, 14 Mar 2019 14:28:45 +0800</pubDate><author>作者</author><guid>http://example.org/object_oriented/</guid><description>范式 “程序设计有一个范式（paradigm）问题。所谓范式，就是组织程序的基本思想，而这个基本思想，反映了程序设计者对程序的一个基本的哲学观</description></item></channel></rss>