[{"categories":null,"content":"关于 ","date":"2021-03-05","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["skynet"],"content":"skynet ","date":"2017-09-18","objectID":"/skynet/:1:0","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["skynet"],"content":"skynet 核心层 skynet 的核心层分为 service, socket, timer, monitor 四个模块 service 实现了 actor 模型，是最重要的一个模块。其又依赖 handle, mq, module 三个模块。 handle 管理 actor 的生命周期，采用了一种常用的 id 映射和引用计数手法，好处在于可以用 handle 检测对象是否有效。 mq 是消息队列和服务队列的常规实现，用自旋锁保证线程安全。 module 是动态库加载，因为 skynet 约定用动态库来承载服务。 服务的调度是基于多线程的，比例为 m:n，每个服务只能被一个线程持有 socket 实现了一个线程安全的 proactor 模式，之所以放在核心层是为了避免调度的开销。 timer 时间轮算法的计时器，放在核心层同 socket。 monitor 提供了死循环，消息录像，消息处理开销三种监测。 ","date":"2017-09-18","objectID":"/skynet/:1:1","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["skynet"],"content":"lua 支持 好处： 动态语言的便捷和安全 用 lua 的协程可以消除异步回调的分隔 skynet 核心是以动态库为承载的，所以要支持 lua 必须要做两件事： 提供一个 c 服务来做 lua 的宿主 将核心层的外部接口封装为 lua 库 snlua 是宿主，lua-skynet.c 是 lua 库 ","date":"2017-09-18","objectID":"/skynet/:1:2","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["skynet"],"content":"skynet 的运行流程 /skynet-src/skynet_main.c 加载配置文件，嵌入 lua 代码，是为了方便，在 lua 层解析比用 c api 方便。 /skynet-src/skynet_start.c 初始化子模块，创建工作线程。 创建日志服务，bootstrap 服务。 ","date":"2017-09-18","objectID":"/skynet/:1:3","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["skynet"],"content":"参考 skynet GitHub skynet wiki 云风 blog ","date":"2017-09-18","objectID":"/skynet/:2:0","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["skynet"],"content":"记录 基于 skynet 的 MMO 服务器设计 IDE 不是程序员的唯一选择（一） IDE 不是程序员的唯一选择（二） IDE 不是程序员的唯一选择（三） IDE 不是程序员的唯一选择（四） IDE 不是程序员的唯一选择（五） IDE 不是程序员的唯一选择（终） skynet 框架应用 skynet 源码赏析 skynet 服务的本质和缺陷 ","date":"2017-09-18","objectID":"/skynet/:2:1","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["Lua"],"content":"Lua tabel 与元表 ","date":"2017-09-18","objectID":"/lua_table/:1:0","tags":["Lua"],"title":"Lua table","uri":"/lua_table/"},{"categories":["Lua"],"content":"table 常用函数 -- 获取参数表 table，并对这个 table 预定义一个字段 n（表示该表的长度）。 local arg = table.pack(...) for i = 1, arg.n do print(i, arg[i]) end --[[ 提供一个列表，其所有元素都是字符串或数字，返回字符串 list[i]..sep..list[i+1] ··· sep..list[j]。 sep 的默认值是空串， i 的默认值是 1 ， j 的默认值是 #list 。 如果 i 比 j 大，返回空串。 ]] table.concat(list [, sep [, i [, j]]]) --[[ 在 list 的位置 pos 处插入元素 value ， 并后移元素 list[pos], list[pos+1], ···, list[#list] 。 pos 的默认值为 #list+1 ， 因此调用 table.insert(t,x) 会将 x 插在列表 t 的末尾。 ]] table.insert(list, [pos,] value) --[[ 将元素从表 a1 移到表 a2。 这个函数做了次等价于后面这个多重赋值的等价操作： a2[t],··· = a1[f],···,a1[e]。 a2 的默认值为 a1。 目标区间可以和源区间重叠。 索引 f 必须是正数。 ]] table.move(a1, f, e, t [, a2]) --[[ 移除 list 中 pos 位置上的元素，并返回这个被移除的值。 当 pos 是在 1 到 #list 之间的整数时， 它向前移动元素　list[pos+1], list[pos+2], ···, list[#list] 并删除元素 list[#list]； 索引 pos 可以是 #list + 1 ，或在 #list 为 0 时可以是 0 ； 在这些情况下，函数删除元素 list[pos]。 pos 默认为 #list， 因此调用 table.remove(l) 将移除表 l 的最后一个元素。 ]] table.remove(list [, pos]) --[[ 在表内从 list[1] 到 list[#list] 原地 对其间元素按指定次序排序。 如果提供了 comp ， 它必须是一个可以接收两个列表内元素为参数的函数。 当第一个元素需要排在第二个元素之前时，返回真 （因此 not comp(list[i+1],list[i]) 在排序结束后将为真）。 如果没有提供 comp， 将使用标准 Lua 操作 \u003c 作为替代品。 排序算法并不稳定； 即当两个元素次序相等时，它们在排序后的相对位置可能会改变。 ]] table.sort(list [, comp]) --[[ 返回列表中的元素。 这个函数等价于 return list[i], list[i+1], ···, list[j] i 默认为 1 ，j 默认为 #list。 ]] table.unpack(list [, i [, j]]) table 的深拷贝 --[[ 一般表的复制都是引用，深拷贝需要实现：1、值的复制，2、方法的复制 所以要解决 3 个问题： 1、table 存在循环引用 2、metatable（metatable 都不参与复制） 3、keys 也是 table ]] function deepcopy(obj) local Table = {} local function func(obj) if type(obj) ~= \"table\" then return end local newtable = {} Table[obj] = newtable for k, v in pairs(obj) do newtable[func(k)] = func(v) end return setmetatable(newtable, getmetatable(obj)) end return func(obj) end ","date":"2017-09-18","objectID":"/lua_table/:1:1","tags":["Lua"],"title":"Lua table","uri":"/lua_table/"},{"categories":["Lua"],"content":"元表 ","date":"2017-09-18","objectID":"/lua_table/:1:2","tags":["Lua"],"title":"Lua table","uri":"/lua_table/"},{"categories":["Lua"],"content":"参考链接 lua table 的内部实现 ","date":"2017-09-18","objectID":"/lua_table/:2:0","tags":["Lua"],"title":"Lua table","uri":"/lua_table/"},{"categories":["Lua"],"content":"Lua 面向对象 ","date":"2017-09-16","objectID":"/lua_object_oriented/:1:0","tags":["Lua"],"title":"Lua 面向对象","uri":"/lua_object_oriented/"},{"categories":["Lua"],"content":"隐藏 self 参数 用 lua 进行面向对象的编程 声明方法和调用方法统一用 “:” 属性的定义和调用全部用 “.” 定义的时候冒号默认接收 self 参数，调用的时候默认传递调用者自身作为参数，而点号要显式传递或接收 self 参数。 ","date":"2017-09-16","objectID":"/lua_object_oriented/:2:0","tags":["Lua"],"title":"Lua 面向对象","uri":"/lua_object_oriented/"},{"categories":["Lua"],"content":"一个简单的类 function class(classname, super) local superType = type(super) local cls if superType ~= \"function\" and superType ~= \"table\" then superType = nil super = nil end -- inherited(继承) from Lua Object if super then -- 复制基类方法 cls = {} setmetatable(cls, {__index = super}) cls.super = super else cls = {ctor = function() end} -- 构造函数 end cls.__cname = classname cls.__index = cls function cls.new(...) -- 实例化 local obj_data = {} local cls_name = cls.__cname local instance = setmetatable(obj_data, cls) instance.class = cls instance:ctor(...) return instance end return cls end 在 lua 中不存在类的定义这样的概念，不管是类的定义还是类的实例都是通过 lua table 来模拟的。实现的 lua 面向对象是 prototype（原型）方式的，即类是一个 lua table，这个 table 定义了类的原型，而类的实例是基于这个原型的另一个 lua table。 实现 lua 面向对象可以分解为类的定义和类的实例化两部分。类的定义主要实现继承，让子类拥有父类的方法集；类的实例化需要解决实例对象如何共享类的方法集，但独享自己的成员变量实例。 子类在定义时复制所有基类的方法，在实例化时将该类作为 metatable 的 __index 赋值给实例。 ","date":"2017-09-16","objectID":"/lua_object_oriented/:3:0","tags":["Lua"],"title":"Lua 面向对象","uri":"/lua_object_oriented/"},{"categories":["manual"],"content":"什么是 Git？ Git 是分布式版本控制系统 ","date":"2017-08-24","objectID":"/git/:1:0","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"SVN 和 Git SVN 是集中式版本控制系统，版本库集中在中央服务器，在个人电脑上从中央服务器 Update 得到最新的版本，在完成工作后，再 commit 到中央服务器。集中式版本控制系统必须联网才能工作，不管是互联网还是局域网。 Git 是分布式版本控制系统，没有中央处理器，个人的电脑就是一个完整的版本库，工作不需要联网。多人各自在自己电脑上对文件进行修改，再将各自的修改推送给他人，这样就可以相互看到别人的修改。 ","date":"2017-08-24","objectID":"/git/:2:0","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"安装 Git 下载地址：Git 如果要修改安装位置，请放在纯英文路径下， 安装完成后在 Terminal 输入 git 出现提示说明安装成功。 点击鼠标右键，选择 Git Bash here ，就可以使用 Git 命令行工具，Git Bash 使用的是 MinGW。 ","date":"2017-08-24","objectID":"/git/:3:0","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"Git 的基本使用 ","date":"2017-08-24","objectID":"/git/:4:0","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"配置 Git 本地创建 shh key： $ ssh-keygen -t rsa -C “18819457397@163.com” // 邮箱是你在 GitHub 上注册的邮箱 回车之后会要求确认路径和输入密码，使用默认的一路回车即可。 成功之后会在 C:\\Users\\Administrator 下生成 .ssh 文件夹，打开文件夹下的 id_rsa.pub 文件，复制里面的 key。 回到 Github 主页，进入 Setting，左边选择 SSH and GPG keys，New SSH Key，Title 随便填，将刚才复制的 key 粘贴到 Key 里，点击 Add SHH Key 完成。 验证连接是否成功，在 Git bash 下输入： $ ssh -T git@github.com 第一次输入会提示是否 continue，输入 yes 会看到： 表示已经成功连接 github。 设置 username 和 Email，github 每次 commit 都会记录它们。 $ git config –global user.name “bqwhnn” $ git config –global user.email “18819457397@163.com” 注意：git config –global 参数，表示你在这台机器上的所有 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和邮箱。 添加远程地址，将仓库连接到远程服务器 $ git remote add origin https://github.com/bqwhnn/bqwhnn.github.io.git // bqwhnn 是 github 的用户名，bqwhnn.github.io 是新建的仓库 进入 .git，打开 config，可以直接修改内容配置远程地址 ","date":"2017-08-24","objectID":"/git/:4:1","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"Git 操作 版本库 版本库又名仓库，英文名为 repository，这个仓库（目录）里的所有文件都可以被 Git 管理起来，Git 能追踪每个文件的修改和删除，Git 在任何时刻都能追踪历史，也可以在将来某个时刻将文件“还原”。 创建本地仓库 $ mkdir XXXX // 创建文件夹 $ pwd // 显示当前目录 $ git init // 将当前目录变成 git 可以管理的仓库 当前目录下会多出一个 .git 的目录，是 Git 来跟踪管理版本的。 创建远端服务器仓库的克隆版本 $ git clone https://github.com/bqwhnn/bqwhnn.github.io.git 工作流 本地仓库由 Git 维护的**三棵“树”**组成。工作目录：持有实际文件；暂存区（Index）：临时保存改动；HEAD：指向最后一次提交的结果。 Git 基本工作流程第一步，将改动添加到暂存区： $ git add $ git add * $ git add . $ git status // 提交文件前查看改动状态 第二歩，实际提交改动到 HEAD，还未到远程仓库 $ git commit -m “代码提交信息” ","date":"2017-08-24","objectID":"/git/:4:2","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"推送改动 第三步，将本地仓库的 HEAD 中的改动提交到远端仓库 $ git push origin master // master 可以改为想要推送的任何分支 如果还没有克隆现有仓库，又想将仓库连接到某个远程服务器并推送改动： $ git remote add origin 分支 分支是用来将特性开发绝缘开来的。创建仓库时，master 是“默认的”主分支，在其他分支上开发完成后，可以将它们合并到主分支。 $ git checkout -b XXXXX // 创建分支 $ git checkout master // 切换回主分支 $ git branch -d XXXXX // 删除分支 $ git push origin // 将分支推送到远端仓库 更新和合并 $ git pull [origin master] // 更新本地仓库至最新改动 在你的工作目录中*获取（fetch）并合并（merge）*远端的改动 $ git merge // 合并其他分支到当前分支 Git 在尝试自动合并改动时并非每次都成功，可能出现冲突（conflicts）。 这时需要修改这些文件来手动合并冲突（conflicts），改完之后执行命令将它们标记为合并成功。 $ git add $ git diff \u003csource_branch\u003e \u003ctarget_branch\u003e 合并改动之前，可以用 diff 命令预览差异 标签 为软件发布创建标签是推荐的 $ git tag 1.0.0 1b2e1d63ff // 创建名为 1.0.0 的标签，后面是 ID 前几位 $ git log // 获取提交 ID 替换本地改动 git checkout – 使用 HEAD 中的最新内容替换工作目录文件，已添加到暂存区的改动和新文件不会受到影响。 $ git fetch origin $ git reset –hard origin/master 丢弃本地的所有改动和提交，到远程服务器获取最新的版本历史，并将本地分支指向它。 ","date":"2017-08-24","objectID":"/git/:4:3","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"参考 常用 Git 命令清单 Git 工作流程 Github 简明教程 git - 简明指南 ","date":"2017-08-24","objectID":"/git/:5:0","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"使用 github pages 首先在 github 中建立一个基于自己用户名的 repository：比如我建立一个名为 bqwhnn.github.io 的 repo。 系统在检测到这样格式的 repo 文件名后，会在 setting 中自动开启 GitHub Pages 功能。之后可以将这个 repo clone 到本地进行修改，在里面上传的网页就是你的网站的内容。 ","date":"2017-08-24","objectID":"/jekyll_github_page/:1:0","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"部署 jekyll ","date":"2017-08-24","objectID":"/jekyll_github_page/:2:0","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"前置：Ruby Mac 和 Linux 可以用 Terminal 配合 yum 或者 brew 这样的包管理器来安装 ruby，Windows 下可以更方便地使用集成好的 RubyInstaller 进行安装。 ","date":"2017-08-24","objectID":"/jekyll_github_page/:2:1","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"RubyGems gem 是一个 ruby 的包管理系统，使用 gem 可以方便的在本地安装 ruby 应用。 安装方法 // 在 RubyGems 官网下载压缩包，解压到本地任意位置 // 在 Terminal 中输入 $ cd your path to RubyGems // 解压位置 $ ruby setup.rb ","date":"2017-08-24","objectID":"/jekyll_github_page/:2:2","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"安装 jekyll 类似 nodejs 和 npm 的包安装，使用 gem 安装 jekyll，直接在 Terminal 中输入： $ gem install bundler // 先安装依赖包 bundler $ gem install jekyll jekyll 模板网站：Jekyll Themes 使用模板可能会缺少东西，看错误提示缺什么直接 $ gem install XXXX ","date":"2017-08-24","objectID":"/jekyll_github_page/:2:3","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"网站预览 $ cd your website path $ jekyll serve // 一个开发服务器将会运行在 http://localhost:4000/ // 在浏览器输入网址就可以在本地服务器看到网站 ","date":"2017-08-24","objectID":"/jekyll_github_page/:2:4","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"参考 github上利用jekyll搭建自己的blog的操作顺序？ jekyll博客搭建之艰辛之路 ","date":"2017-08-24","objectID":"/jekyll_github_page/:3:0","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"}]