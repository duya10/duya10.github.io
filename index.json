[{"categories":null,"content":"关于 ","date":"2021-03-05","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["manual"],"content":"开启core，采集程序崩溃的状态 在 /etc/profile 最后一行添加内容，设置全局开启 croe 文件调试，大小不限，然后立即生效 vi /etc/profile # No core files by default 0, unlimited is oo ulimit -S -c unlimited \u003e /dev/null 2\u003e\u00261 source /etc/profile 在 /etc/sysctl.conf 添加 core 文件命名规则，变成 core.pid 格式，防止覆盖，并立即启用 vi /etc/sysctl.conf # open, add core.pid kernel.core_pattern = ./core_%t_%p_%e kernel.core_uses_pid = 1 sysctl -p /etc/sysctl.conf core 启用成功，ulimit -c 可以查看是否启用成功，如果为0表示没有开启 ","date":"2019-07-09","objectID":"/gdb/:1:0","tags":["GDB"],"title":"GDB 调试","uri":"/gdb/"},{"categories":["manual"],"content":"GDB 常用命令 命令 意义 r/run 开始运行调试 l/list [v] 列出代码，不带参数则记忆向下滚动10行，v 可以是行号，函数名，当前行号的正负偏移量 n/next [n] 执行[n 次]下一步代码，会跳过函数 b/break n [if] 在当前文件的第 n 行设置断点，可选设置条件断点 s/step 执行下一步代码，遇到函数会进入函数内部 p/print 输出数据 c/continue 继续运行程序直到下一个断点 bt/backtrace 显示调用栈信息 q/quit 退出 gdb 调试 k/kill 终止正在调试的程序 info command info breakpoints 显示当前断点信息，info args 查看当前函数参数值，info locals 查看当前函数栈上值信息，info registers 查看寄存器信息，info threads 显示所有运行的线程信息 … d/delete [n] 删除索引为 n 的断点，若不带参数，则删除所有断点 clear n 删除第 n 行的断点 多线程调试 info threads 显示所有运行的线程信息 t/thread id 多线程调试，切换到指定 id 的线程 set scheduler-locking on/off 设置多线程单独调试开启/关闭，开启会使其他线程阻塞 多进程调试 ps -ef 可查找需要调试的进程 attach pid 将 pid 进程加载进来，加载的进程会阻塞到当前正在运行的地方 info inferiors 查看正在调试的进程 inferior pid 切换调试的进程 ","date":"2019-07-09","objectID":"/gdb/:2:0","tags":["GDB"],"title":"GDB 调试","uri":"/gdb/"},{"categories":["manual"],"content":"查看内存信息 (gdb) x /23dw a 从 a 地址开始 23 个 4 字节有符号十进制数输出 通用格式 (gdb) x /nfu ptr x 是 examine 的缩写 n 表示要显示的内存单元个数 f 表示显示方法 x 按十六进制格式显示 d 有符号十进制格式 u 无符号十进制格式 o 八进制格式 t 二进制格式 a 十六进制格式 i 指令地址格式 c 字符格式 f 浮点数格式 u 表示一个地址单元的长度 b 表示单字节 h 双字节 w 四字节 g 八字节 ptr 表示从这个地址开始显示 ","date":"2019-07-09","objectID":"/gdb/:2:1","tags":["GDB"],"title":"GDB 调试","uri":"/gdb/"},{"categories":["manual"],"content":"参考链接 Linux基础 30分钟GDB调试快速突破 gdb调试多进程和多线程命令 ","date":"2019-07-09","objectID":"/gdb/:3:0","tags":["GDB"],"title":"GDB 调试","uri":"/gdb/"},{"categories":["manual"],"content":"gcc 编译流程 GCC 编译器编译一个 C 语言程序分为四个阶段： 预处理阶段（Pre-Processing）：将头文件内容添加到程序里面，生成 .i 文件 编译阶段（Compiling）：将 .i 文件编译成汇编语言，生成 .s 文件 汇编阶段（Assembling）：将 .s 文件编译成机器指令，生成目标文件 .o 文件 链接阶段（Linking）：将各个模块的 .o 文件链接起来生成一个可执行目标文件 gcc 命令 gcc -E hello.c -o hello.i gcc -S hello.i -o hello.s gcc -c hello.s -o hello.o gcc hello.o -o hello ","date":"2019-07-08","objectID":"/gcc/:1:0","tags":["GCC"],"title":"GCC 命令","uri":"/gcc/"},{"categories":["manual"],"content":"gcc 常用选项 选项 意义 -c 预处理、编译、汇编指定源文件，不进行链接，生成 .o 的 obj 文件 -S 预处理、编译指定源文件，生成 .s 的汇编文件 -E 只进行预处理，不生成文件，需要 -o 指定或者重定向生成 .i 文件 -o [file1] [file2] 将文件 file2 编译成可执行文件 file1 -C 在预处理的时候, 不删除注释信息, 一般和-E使用, 有助于分析程序 -g -g选项可生成能被 gdb 调试器所使用的调试信息。只有使用了该选项后生成的可执行文件，才带有程序中引用的符号表。这时 gdb 调试程序才能对该可执行程序进行调试 -O0 、-O1 、-O2 、-O3 编译器的优化选项的 4 个级别，-O0 表示没有优化, -O1为 缺省值，-O3 优化级别最高。 -shared 生成共享目标文件。通常用在建立共享库时 -static 禁止使用共享连接 -w 不生成任何警告信息 -W 生成所有警告信息 -fPIC 作用于编译阶段，告诉编译器产生与位置无关的代码（Position-Independent Code） -l[lib] 指定程序要链接的库，lib 是库名，数学库的文件名是 libm.so，那么 -lm 就代表链接数学库，同理 -ldl 代表链接加载动态库的 libdl.so 库 ","date":"2019-07-08","objectID":"/gcc/:2:0","tags":["GCC"],"title":"GCC 命令","uri":"/gcc/"},{"categories":["manual"],"content":"gcc 生成动态链接库 从源文件生成动态链接库： gcc -fPIC -shared func.c -o libfunc.so 从目标文件生成动态链接库： gcc -fPIC -c func.c -o func.o gcc -shared func.o -o libfunc.so -fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。产生的代码全部使用相对地址，这样代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。 ","date":"2019-07-08","objectID":"/gcc/:3:0","tags":["GCC"],"title":"GCC 命令","uri":"/gcc/"},{"categories":["manual"],"content":"gcc 将动态链接库链接到可执行文件 如果希望将一个动态链接库链接到可执行文件，那么需要在命令行中列出动态链接库的名称，具体方式和普通的源文件、目标文件一样。 gcc main.c libfunc.so -o app.out 将 main.c 和 libfunc.so 一起编译成 app.out，当 app.out 运行时，会动态地加载链接库 libfunc.so。 当然，必须要确保程序在运行时可以找到这个动态链接库。你可以将链接库放到标准目录下，例如 /usr/lib，或者设置一个合适的环境变量，例如 LIBRARY_PATH。不同系统，具有不同的加载链接库的方法。 ","date":"2019-07-08","objectID":"/gcc/:4:0","tags":["GCC"],"title":"GCC 命令","uri":"/gcc/"},{"categories":["Lua"],"content":"gcc 命令 编译使用 lua api 的 c 语言程序 gcc temp.c -o temp -llua -lm -ldl 生成动态链接库供 lua 程序调用 gcc temp.c -o temp.so -fPIV -shared ","date":"2019-07-02","objectID":"/lua_api/:1:0","tags":["Lua"],"title":"Lua API","uri":"/lua_api/"},{"categories":["Lua"],"content":"LUA_API 定义 /* @@ LUA_API is a mark for all core API functions. @@ LUALIB_API is a mark for all auxiliary library functions. @@ LUAMOD_API is a mark for all standard library opening functions. ** CHANGE them if you need to define those functions in some special way. ** For instance, if you want to create one Windows DLL with the core and ** the libraries, you may want to use the following definition (define ** LUA_BUILD_AS_DLL to get it). */ #if defined(LUA_BUILD_AS_DLL) /* { */ #if defined(LUA_CORE) || defined(LUA_LIB) /* { */#define LUA_API __declspec(dllexport) #else /* }{ */#define LUA_API __declspec(dllimport) #endif /* } */ #else /* }{ */ #define LUA_API extern #endif /* } */ /* more often than not the libs go together with the core */ #define LUALIB_API LUA_API #define LUAMOD_API LUALIB_API 函数开头有 LUA_API: LUA_API : 标识核心 API 函数 LUALIB_API : 标识辅助库函数 LUAMOD_API : 标识标准库函数 有特殊需求可以自行修改。默认的，LUA_API、LUALIB_API、LUAMOD_API 是一样的 ","date":"2019-07-02","objectID":"/lua_api/:2:0","tags":["Lua"],"title":"Lua API","uri":"/lua_api/"},{"categories":["Lua"],"content":"lua_lock 和 lua_unlock 定义 /* ** macros that are executed whenever program enters the Lua core ** ('lua_lock') and leaves the core ('lua_unlock') */ #if !defined(lua_lock) #define lua_lock(L) ((void) 0) #define lua_unlock(L) ((void) 0) #endif If you port Lua to another platform, you are “allowed” to overwrite lua_lock with your own definition; and this definition should essentially be a mutex, to disallow cross-thread operations on the same Lua objects. Essentially, when implemented, it should act similarly to Python’s Global Interpreter Lock (GIL). 当需要将 Lua 移植到其他平台时，可以重写 lua_lock。必须注意的是，为了避免线程间对同一 Lua 对象的操作，lua_lock 的定义必须是互斥的，且其实现中其行为应该和 Python 的全局解释器锁（GIL）类似。 lua_lock 和 lua_unlock 主要用于线程间通信的情况，一般情况下我们不需要考虑，Lua 官方也对其做了保留，如果有需要涉及到多线程操作，则需开发者自行实现互斥行为。 ","date":"2019-07-02","objectID":"/lua_api/:3:0","tags":["Lua"],"title":"Lua API","uri":"/lua_api/"},{"categories":["Lua"],"content":"参考链接 Reyn : lua 专题 yuanlin2008 : 探索Lua5.2内部实现 ","date":"2019-07-02","objectID":"/lua_api/:4:0","tags":["Lua"],"title":"Lua API","uri":"/lua_api/"},{"categories":["计算机系统"],"content":"字节序 ","date":"2019-05-14","objectID":"/bytecode/:1:0","tags":["computer"],"title":"理解字节序，大端和小端","uri":"/bytecode/"},{"categories":["计算机系统"],"content":"大端和小端 计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。 数值 0x2211 使用两个字节储存：高位字节是0x22，低位字节是0x11。 大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。 小端字节序：低位字节在前，高位字节在后，即以 0x1122 形式储存。 0x1234567 的大端字节序和小端字节序的写法如下图: ","date":"2019-05-14","objectID":"/bytecode/:1:1","tags":["computer"],"title":"理解字节序，大端和小端","uri":"/bytecode/"},{"categories":["计算机系统"],"content":"为什么会有小端字节序 答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。 但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。 ","date":"2019-05-14","objectID":"/bytecode/:1:2","tags":["computer"],"title":"理解字节序，大端和小端","uri":"/bytecode/"},{"categories":["计算机系统"],"content":"字节序处理 “只有读取的时候，才必须区分字节序，其他情况都不用考虑。” 处理器读取外部数据的时候，必须知道数据的字节序，将其转成正确的值。 如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。 然后，就正常使用这个值，完全不用再考虑字节序。 即使是向外部设备写入数据，也不用考虑字节序，正常写入一个值即可。外部设备会自己处理字节序的问题。 ","date":"2019-05-14","objectID":"/bytecode/:1:3","tags":["computer"],"title":"理解字节序，大端和小端","uri":"/bytecode/"},{"categories":["计算机系统"],"content":"字节序测试程序 不同 cpu 平台上字节序通常也不一样，下面的 C 程序可以测试不同平台上的字节序。 #include \u003cnetinet/in.h\u003e int main(void) { int n = 0x12345678; // 取 n 的地址并强制转换为 char * 类型的指针，每次执行 +1 运算内存偏移 8bit // 一个 16 进制数占据 4bit 内存，所以一次打印两位 16 进制数 printf(\"[0]: 0x%x\\n\", *((char *)\u0026n + 0)); printf(\"[1]: 0x%x\\n\", *((char *)\u0026n + 1)); printf(\"[2]: 0x%x\\n\", *((char *)\u0026n + 2)); printf(\"[3]: 0x%x\\n\", *((char *)\u0026n + 3)); n = htonl(n); printf(\"[0]: 0x%x\\n\", *((char *)\u0026n + 0)); printf(\"[1]: 0x%x\\n\", *((char *)\u0026n + 1)); printf(\"[2]: 0x%x\\n\", *((char *)\u0026n + 2)); printf(\"[3]: 0x%x\\n\", *((char *)\u0026n + 3)); } 另一个程序 void check_endian(uint16_t a) { if (*(char *)\u0026a == 1) printf(\"big endian\\n\"); elseif (*(char *)\u0026a == 2) printf(\"little endian\\n\"); else printf(\"unknown\\n\"); } int main(void) { uint16_t a = 0x0102; uint16_t b = htons(a); check_endian(a); check_endian(b); } 在80X86CPU平台上，执行该程序得到如下结果： [0]:0x78 [1]:0x56 [2]:0x34 [3]:0x12 [0]:0x12 [1]:0x34 [2]:0x56 [3]:0x78 分析结果，在80X86平台上，系统将多字节中的低位存储在变量起始地址，使用小端法。htonl将i_num转换成网络字节序，可见网络字节序是大端法。 ","date":"2019-05-14","objectID":"/bytecode/:2:0","tags":["computer"],"title":"理解字节序，大端和小端","uri":"/bytecode/"},{"categories":["计算机系统"],"content":"参考链接 理解字节序 C语言中大端字节序与小端字节序的转化 ","date":"2019-05-14","objectID":"/bytecode/:3:0","tags":["computer"],"title":"理解字节序，大端和小端","uri":"/bytecode/"},{"categories":["MongoDB"],"content":"更新 ","date":"2019-05-10","objectID":"/mongodb/:1:0","tags":["MongoDB"],"title":"MongoDB 笔记","uri":"/mongodb/"},{"categories":["MongoDB"],"content":"update update 是更新操作，没有返回值 db.collection.update( \u003cquery\u003e, \u003cupdate\u003e, { upsert: \u003cboolean\u003e, multi: \u003cboolean\u003e, writeConcern: \u003cdocument\u003e } ) 参数说明： query : update 的查询条件，类似 sql update 查询内 where 后面的 update : update 的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update 查询内 set 后面的 upsert : 可选，这个参数的意思是，如果不存在 update 的记录，是否插入 objNew , true 为插入，默认是 false，不插入 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为 true，就把按条件查出来多条记录全部更新 writeConcern :可选，抛出异常的级别 ","date":"2019-05-10","objectID":"/mongodb/:1:1","tags":["MongoDB"],"title":"MongoDB 笔记","uri":"/mongodb/"},{"categories":["MongoDB"],"content":"findAndModify findAndModify 有返回值，使用 new 选项可以返回修改前或修改后的文档 findAndModify 强调操作的原子性（atomically），比如用来实现自增1的操作或者操作队列。属于 get-and-set 式的操作，一般来讲，findAndModify 比 update 操作稍慢，因为需要等待数据库的响应。 mongodb 不支持事务，但提供了许多原子操作，文档的保存，修改，删除等都是原子操作 原子操作保证一个文档要么保存到 mongodb，要么没有保存到，不会出现查询到的文档没有保存完整的情况 db.collection.findAndModify({ query: \u003cdocument\u003e, sort: \u003cdocument\u003e, remove: \u003cboolean\u003e, update: \u003cdocument\u003e, new: \u003cboolean\u003e, fields: \u003cdocument\u003e, upsert: \u003cboolean\u003e, bypassDocumentValidation: \u003cboolean\u003e, writeConcern: \u003cdocument\u003e, collation: \u003cdocument\u003e, arrayFilters: [ \u003cfilterdocument1\u003e, ... ] }); 参数说明： query:{}, 查询条件 update:{}, 更新文档，不能与 remove 同时出现 remove:true, 删除符合查询条件的文档，不能与 update 同时出现 new:true, true 表示返回更新后的文档，false 表示返回更新前的文档，默认 false sort:{}, 排序条件 fields:{}, 投影操作，只返回想要的参数，与 find 的第二个参数一致 upsert:true, 如果不存在要 update 的记录，是否插入，true ：插入，false ：不插入 ","date":"2019-05-10","objectID":"/mongodb/:1:2","tags":["MongoDB"],"title":"MongoDB 笔记","uri":"/mongodb/"},{"categories":["MongoDB"],"content":"$setOnInsert 操作符和 upsert:true upsert:true:如果要更新的文档不存在的话会插入一条新的记录 $setOnInsert 操作符会将指定的值赋值给指定的字段， 如果要更新的文档存在那么 $setOnInsert 操作符不做任何处理； db.collection.update( \u003cquery\u003e, {$setOnInsert:{\u003cfield1\u003e:\u003cvalue1\u003e,......}}, {upsert:true} ) $set 和 $setOnIsert 不能对同一字段使用 如果该文档不存在，则会创建一个新的文档，$set 和 $setOnInsert 操作的键值都会插入进入 如果文档存在，那么只会更新 $set 操作符指定的值，忽略掉 $setOnInsert 指定的值 实例: db.products.update( {_id:　1}, { $set:{item:\"apple\"}, $setOnInsert:{defaultQty:100} }, {upsert:true} ) ","date":"2019-05-10","objectID":"/mongodb/:1:3","tags":["MongoDB"],"title":"MongoDB 笔记","uri":"/mongodb/"},{"categories":["MongoDB"],"content":"原子操作常用命令 $set 更新键值，若键不存在则创建 { $set : { field : value } } $unset 删除一个键 { $unset : { field : 1 } } $inc 对值为数字的键进行加分运算，value 可以是正数也可以是负数 { $inc : { field : value } } $push 把 value 追加到 field 里面去，field 一定要是数组类型才行，如果 field 不存在，会新增一个数组类型加进去 { $push : { field : value } } $pushAll 同 $push ,只是一次可以追加多个值到一个数组字段内，value_array 是数组类型 { $pushAll : { field : value_array } } $pull 从数组 field 内删除一个等于 value 的元素 { $pull : { field : value } } $addToSet 增加一个值到数组内，而且只有当这个值不在数组内才增加。 { $addToSet : { field : value } } $pop 删除数组的第一个或最后一个元素 { $pop : { field : 1 } } 删除最后一个元素 { $pop : { field : -1 } } 删除第一个元素 $rename 修改字段名称 { $rename : { old_field_name : new_field_name } } $bit 位操作，integer类型 {$bit : { field : {and : 5}}} 偏移操作符 t.find() { “_id” : ObjectId(“4b97e62bf1d8c7152c9ccb74”), “title” : “ABC”, “comments” : [ { “by” : “joe”, “votes” : 3 }, { “by” : “jane”, “votes” : 7 } ] } t.update( {‘comments.by’:‘joe’}, {$inc:{‘comments.$.votes’:1}}, false, true ) t.find() { “_id” : ObjectId(“4b97e62bf1d8c7152c9ccb74”), “title” : “ABC”, “comments” : [ { “by” : “joe”, “votes” : 4 }, { “by” : “jane”, “votes” : 7 } ] } ","date":"2019-05-10","objectID":"/mongodb/:1:4","tags":["MongoDB"],"title":"MongoDB 笔记","uri":"/mongodb/"},{"categories":["MongoDB"],"content":"参考链接 MongoDB 4.0手册 ","date":"2019-05-10","objectID":"/mongodb/:2:0","tags":["MongoDB"],"title":"MongoDB 笔记","uri":"/mongodb/"},{"categories":["C"],"content":"指针 ","date":"2019-04-19","objectID":"/c_mark/:1:0","tags":["C"],"title":"C 笔记","uri":"/c_mark/"},{"categories":["C"],"content":"有效的指针运算 相同类型指针之间的赋值运算 指针同整数之间的加减运算 指向相同数组中元素的两个指针间的减法或比较运算（相减得到二者之间的元素个数，==、!=、\u003c、\u003e= 等可以针对二者在数组中的位置进行比较） 将指针赋值为 0 或指针和 0 之间的比较运算 不经过强制类型转换而直接把指向一种类型对象的指针赋值给指向另一种类型对象的指针是不合法的，除非其中之一是 void * 类型的指针。 ","date":"2019-04-19","objectID":"/c_mark/:1:1","tags":["C"],"title":"C 笔记","uri":"/c_mark/"},{"categories":["C"],"content":"指针数组与多维数组 int a[10][20]; int *b[10]; // 10 个指针元素 如果同样存储 10X20 的的元素，二维数组 a 分配 200 个 int 类型长度的存储空间，而指针数组 b 还要额外分配 10 个指针的存储空间。 指针数组的优势在于每个指针元素可以指向不同长度，比较频繁用于存放具有不同长度的字符串。 char *month[] = {“January”, “February”, “March”, “April”, “May”, “June”, “July”, “August”, “September”, “October”, “November”, “December”}; ","date":"2019-04-19","objectID":"/c_mark/:1:2","tags":["C"],"title":"C 笔记","uri":"/c_mark/"},{"categories":["C"],"content":"复杂声明 int *f() int (*pf)() f 是函数，返回值是指向 int 类型的指针 pf 是指针，指向一个返回值是 int 的函数 * 是一个前缀运算符，其优先级低于函数调用 () char **argv int (*pa)[13] int *a[13] argv 是指针，指向 char * pa 是指针，指向 array[13] of int（保存 13 个 int 元素的数组） a 是数组，保存了 13 个指向 int 类型的指针 ","date":"2019-04-19","objectID":"/c_mark/:1:3","tags":["C"],"title":"C 笔记","uri":"/c_mark/"},{"categories":["C"],"content":"函数指针 C 的函数指针很强大，但是并不具备闭包的功能。 struct node { int val; struct node *next; } typedef void (*print_node)(struct node *, int); void func(struct node *t, int i) { printf(\"%d: %d\\n\", i++, t-\u003eval); } // void foreach(struct node *t, print_node f) void foreach(struct node *t, void (*f)(struct node *, int)) { int i = 0; while (t) { f(t, i); t = t-\u003enext; } } int main(void) { print_node f; f = func; struct node *root = NULL, *t = NULL; int i; for (i = 0; i \u003c 10; i++) { t = (struct node *)malloc(sizeof(struct node)); t-\u003eval = i; t-\u003enext = root; root = t; } foreach(root, func); return 0; } ","date":"2019-04-19","objectID":"/c_mark/:1:4","tags":["C"],"title":"C 笔记","uri":"/c_mark/"},{"categories":["C"],"content":"位运算 x^y = (x\u0026~y) | (~x\u0026y) ","date":"2019-04-19","objectID":"/c_mark/:2:0","tags":["C"],"title":"C 笔记","uri":"/c_mark/"},{"categories":["计算机系统"],"content":"原码、反码和补码 我们以八位的二进制示例 ","date":"2019-04-10","objectID":"/complement_code/:1:0","tags":["computer"],"title":"原码、反码和补码","uri":"/complement_code/"},{"categories":["计算机系统"],"content":"机器数和真值 一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1。 例子：十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 ，此处 00000011 和 10000011 是机器数，+3 和 -3 是真值。 ","date":"2019-04-10","objectID":"/complement_code/:1:1","tags":["computer"],"title":"原码、反码和补码","uri":"/complement_code/"},{"categories":["计算机系统"],"content":"原码 使用第一位作为符号位，后面表示数值 +1 : 0000 0001 -1 : 1000 0001 所以8位二进制数的取值范围是： [1111 1111, 0111 1111] = [-127, 127] ","date":"2019-04-10","objectID":"/complement_code/:1:2","tags":["computer"],"title":"原码、反码和补码","uri":"/complement_code/"},{"categories":["计算机系统"],"content":"反码 正数的反码是其本身 负数的反码是符号位不变，其余各位取反 +1 : 0000 0001 -1 : 1111 1110 ","date":"2019-04-10","objectID":"/complement_code/:1:3","tags":["computer"],"title":"原码、反码和补码","uri":"/complement_code/"},{"categories":["计算机系统"],"content":"补码 正数的补码是其本身 负数的反码是符号位不变，其余各位取反，最后 +1 +1 : 0000 0001 -1 : 1111 1111 在原码和反码中，由于符号位的存在，0000 0000[+0] 和 1000 0000[-0] 存在两个 0 值 而在补码中，0000 0000 表示 0，1000 0000 表示 -128 (-1) + (-127) = [1111 1111] + [1000 0001] = [1000 0000] 即 -128 使用补码，不仅没有 0 存在两个编码的问题，还多了一个最低数。 所以在8位二进制中，使用原码或反码表示范围是[-127,+127]，而使用补码表示范围是[-128,+127]。 因为机器使用补码，所以对于编程中常用到的32位int类型，可以表示范围是: [-231, 231-1]，因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。 ","date":"2019-04-10","objectID":"/complement_code/:1:4","tags":["computer"],"title":"原码、反码和补码","uri":"/complement_code/"},{"categories":["计算机系统"],"content":"参考链接 原码、反码、补码知识详细讲解 ","date":"2019-04-10","objectID":"/complement_code/:2:0","tags":["computer"],"title":"原码、反码和补码","uri":"/complement_code/"},{"categories":["Go"],"content":"go module Go 1.11 版本发布之后，官方引入了 go module 来解决依赖管理的问题，go module 被集成到原生的 go cmd 中。 go modules wiki 使用 Go Module 深入浅出Go Modules ","date":"2019-03-29","objectID":"/gomod_goproxy/:1:0","tags":["Go"],"title":"Go mod 和 goproxy","uri":"/gomod_goproxy/"},{"categories":["Go"],"content":"goproxy Go 1.00 版本还新增了 GOPROXY 环境变量。如果设置了该变量，下载源代码时将会通过这个环境变量设置的代理地址，而不再是以前的直接从代码库下载。我们可以通过这个解决之前获取 go get golang.org/x 包失败的问题。 goproxy.io 这个开源项目帮我们实现好了我们想要的。该项目允许开发者一键构建自己的 GOPROXY 代理服务。同时，也提供了公用的代理服务 https://goproxy.io，我们只需设置该环境变量即可正常下载被墙的源码包了： export GOPROXY=https://goproxy.io 通过置空这个环境变量来关闭: export GOPROXY= 新发现的访问速度更快的 GOPROXY 地址 export GOPROXY=https://goproxy.cn ","date":"2019-03-29","objectID":"/gomod_goproxy/:2:0","tags":["Go"],"title":"Go mod 和 goproxy","uri":"/gomod_goproxy/"},{"categories":["Go"],"content":"陷阱 ","date":"2019-03-22","objectID":"/go_advanced/:1:0","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"引用和指针 silce, map, channel 是引用，内部数据结构包含了底层数据结构的指针，所以作为函数参数在函数中改变其中的值能够生效。 其余数据类型在作为函数参数时，由于函数传参是值拷贝，所以如果需要在函数中改变值，就需要传指针。 ","date":"2019-03-22","objectID":"/go_advanced/:1:1","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"跳出 for-switch 和 fo-select 代码块 没有指定标签的 break 只会跳出 switch/select 语句，若不能使用 return 语句跳出，可以为 break 跳出标签指定的代码块。 goto 虽然也能跳转到指定位置，但是会再次进入 for-switch，形成死循环。 func main() { loop: for { switch { case true: fmt.Println(\"break\") break } } fmt.Println(\"done\") } ","date":"2019-03-22","objectID":"/go_advanced/:1:2","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"defer 函数的参数值 对 defer 延迟执行的函数，它的参数会在声明时候就执行表达式，而不是执行函数的时候才执行。 func main() { var i = 1 defer fmt.Println(\"result: \", func() int {return i * 2}()) i++ } # result: 2 ","date":"2019-03-22","objectID":"/go_advanced/:1:3","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"类型声明与方法 从一个现有的非 interface 类型创建新类型，不会继承原有的方法； 将原类型以匿名字段的形式嵌到自定义的新的 struct 中，可以使用原类型的方法； 使用 interface 类型创建新类型，保留了原类型的方法集。 type Locker1 sync.Mutex type Locker2 struct { sync.Mutex } type Locker3 sync.Locker func main() { var locker Locker1 locker.Lock() // 报错 locker.Unlock() // 报错 var locker Locker2 locker.Lock() // OK locker.Unlock() // OK var locker Locker3 locker.Lock() // OK locker.Unlock() // OK } ","date":"2019-03-22","objectID":"/go_advanced/:1:4","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"堆栈变量 Go 编译器会根据变量的大小和 “escape analysis” 的结果来决定变量的存储位置，所以可以准确返回本地变量的地址。 在 go build 或 go run 时，加入 -m，能准确分析程序的变量分配的栈堆位置： go run -gcflags -m main.go ","date":"2019-03-22","objectID":"/go_advanced/:1:5","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"并发和锁 ","date":"2019-03-22","objectID":"/go_advanced/:2:0","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"nil channel 在一个值为 nil 的 channel 上发送和接收数据将永久阻塞，利用这个死锁的特性，可以用在 select 中动态地选择发送或接收的 channel。 ","date":"2019-03-22","objectID":"/go_advanced/:2:1","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"实现同步 题目描述: 编写一个程序，开启 3 个线程 A,B,C，这三个线程的输出分别为 A、B、C，每个线程将自己的 输出在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。如：ABCABCABC…. 关键点： 开 3 个线程 每个线程将自己的输出打印 每个线程都打印 10 遍 func main() { ch1 := make(chan string) ch2 := make(chan string) ch3 := make(chan string) done := make(chan struct{}) go func() { for { print(\u003c-ch1) ch2 \u003c- \"B\" } }() go func() { for { print(\u003c-ch2) ch3 \u003c- \"C\" } }() go func() { for i := 1; i \u003c= 10; i++ { print(\u003c-ch3) ch1 \u003c- \"A\" } done \u003c- struct{}{} }() ch1 \u003c- \"A\" \u003c-done } 进一步思考： 编写一个程序，开启 N 个线程 A,B,C…，这 N 个线程的输出分别为 A、B、C…，每个线程将自己的输出在屏幕上打印 M 遍，要求输出的结果必须按顺序显示。如：ABC…ABC…ABC… 其中 N \u003c= 1000, M \u003c= 1000 var ( N = 3 M = 10 ) func main() { // wait 表示等待信号的管道，signal 表示发送信号的管道 var wait, signal, firstWait, lastSignal chan struct{} wait = make(chan struct{}) firstWait = wait // 从主 goroutine 发送到第一个 for i := 0; i \u003c N; i++ { signal = make(chan struct{}) go echo(i, wait, signal) wait = signal // 通过这个连接两个 goroutine } lastSignal = signal // 最后一个把信号发回主 goroutine for i := 0; i \u003c M; i++ { firstWait \u003c- struct{}{} \u003c-lastSignal } close(firstWait) // 关闭管道，不再接收数据 } func echo(num int, wait chan struct{}, signal chan struct{}) { letter := string('A' + num) for _ = range wait { fmt.Println(letter) signal \u003c- struct{}{} } close(signal) } ","date":"2019-03-22","objectID":"/go_advanced/:2:2","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"FanIn 通过将多个输入 channel 多路复用到单个处理 channel 的方式，一个函数能够从多个输入 channel 中读取数据并处理。当所有的输出 channel 都关闭的时候，单个处理 channel 也会关闭。这就叫做扇入。 这里主要将 N 个 channel 的输出输入到一个 channel 中。 var ( N = 3 M = 10 ) func gen(v string, times int) \u003c-chan string { ch := make(chan string) go func() { defer close(ch) for i := 0; i \u003c times; i++ { ch \u003c- v } }() return ch } func fanIn(times int, inputs []\u003c-chan string) \u003c-chan string { ch := make(chan string) go func() { defer close(ch) for i := 0; i \u003c times; i++ { for _, input := range inputs { v := \u003c-input ch \u003c- v } } }() return ch } func main() { times := M inputs := make([]\u003c-chan string, 0, N) for i := 0; i \u003c N; i++ { threadName := string('A' + i) inputs = append(inputs, gen(threadName, times)) } for char := range fanIn(times, inputs) { fmt.Println(char) } } ","date":"2019-03-22","objectID":"/go_advanced/:2:3","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"断行规则 在 Go 中，注释除外，如果一个代码行的最后一个语法词段（token）为下列所示之一，则分号将自动插入到行尾： 一个标识符 一个整数、浮点数、虚部、码点或者字符串字面表示形式 跳转关键字之一：break、continue、fallthrough 和 return 自增运算符 ++ 或者自减运算符 – 右括号：)、] 或者 } 为了一条复杂语句完全显示在一个代码行中，分号可能被插入在 ‘)’ 或者 ‘}’ 之前 ","date":"2019-03-22","objectID":"/go_advanced/:3:0","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["Go"],"content":"参考链接 Go 手册 Go 手册(中文) Go 语言中文社区 Go 指南 实效 Go 编程 Go walker Go 夜读 Go 夜读 Go’s Declaration Syntax, 为什么类型在变量后面 Defer, Panic, and Recover Go 切片：用法和本质 Go 优缺点 Go coding in go way Go: the Good, the Bad and the Ugly Golang FAN 模式 项目部署 ","date":"2019-03-22","objectID":"/go_advanced/:4:0","tags":["Go"],"title":"Go 进阶","uri":"/go_advanced/"},{"categories":["编程感悟"],"content":"范式 “程序设计有一个范式（paradigm）问题。所谓范式，就是组织程序的基本思想，而这个基本思想，反映了程序设计者对程序的一个基本的哲学观，也就是说，他认为程序的本质是什么，他认为一个大的程序是由什么组成的。而这，又跟他对于现实世界的看法有关。”――孟岩 编程是为了解决问题，而解决问题可以有多种视角和思路，其中普适且行之有效的模式被归结为范式。 现在的范式一般只有三种，过程范式、函数范式、对象范式。 函数范式与现实世界差距较大，纯函数式范式较少，绝大多数语言只取了函数范式的一个子集，将函数作为参数传递，即函数是一等公民。 过程范式认为，程序是由一个又一个过程经过顺序、选择和循环的结构组合而成。反映在现实世界，过程范式体现了劳动分工之前“全能人”的工作特点——所有的事情都能干，所有的资源都是我的，只不过得具体的事情得一步步地来做。 对象范式则反映了劳动分工之后的团队协作的工作特点——每个人各有所长，各司其职，有各自的私有资源，工件和信息在人们之间彼此传递，最后完成工作。因此，对象范式也就形成了自己对程序的看法——程序是由一组对象组成，这些对象各有所能，通过消息传递实现协作。 ","date":"2019-03-14","objectID":"/object_oriented/:1:0","tags":["OOP"],"title":"面向对象理解","uri":"/object_oriented/"},{"categories":["编程感悟"],"content":"对象范式 对象范式的两个基本观念： 程序是由对象组成的 对象之间互相发送消息，协作完成任务 我们熟悉的面向对象，一般是指封装、继承和多态，要构建一个对象，就先要有一个类的概念，想要向一个对象发送消息，必须先知道这个对象的类型，如此一来，类的概念就特别重要，而对象只是类的一个实例化，面向对象编程，更像是面向类编程。 “组合比继承重要，而且更灵活”，OOP 本质是为了职责分离设计的范式，核心是对象，不一定需要类，OOP 更像是组合、接口。 对象才是第一要素，对象不依赖与类，对象的组合方式是发送消息，发送消息通过接口而不依赖与类。 Go 语言明确了对象范式是“组合+接口”。 ","date":"2019-03-14","objectID":"/object_oriented/:1:1","tags":["OOP"],"title":"面向对象理解","uri":"/object_oriented/"},{"categories":["Go"],"content":"错误是业务过程的一部分，而异常不是 ","date":"2019-02-27","objectID":"/go_errors_and_exceptions/:0:0","tags":["Go"],"title":"Go 错误和异常处理","uri":"/go_errors_and_exceptions/"},{"categories":["Go"],"content":"参考链接 Golang错误和异常处理的正确姿势 ","date":"2019-02-27","objectID":"/go_errors_and_exceptions/:1:0","tags":["Go"],"title":"Go 错误和异常处理","uri":"/go_errors_and_exceptions/"},{"categories":["编程感悟"],"content":"分布式和集群 分布式：一个业务拆分成多个子业务，部署在不同的服务器上 集群：同一个业务，部署的多个服务器上 ","date":"2019-02-23","objectID":"/programming_notes/:1:0","tags":["server"],"title":"编程笔记","uri":"/programming_notes/"},{"categories":["编程感悟"],"content":"并发 在讨论并发的时候，如果说 a 早于 b 发生，那么我们就保证了 a 发生的时间一定早于 b，而且是可以预期的。 当 a 既不比 b 早也不比 b 晚，我们说 a 和 b 并发，这并不说明 a 和 b 一定同时发生，只说明我们不能确定它们的顺序。 对于并发我们必须认识到的一点是：关于并发的直觉都不可靠。 不同的处理器，不同的编译器，都可能产生让你想不到的结果。 ","date":"2019-02-23","objectID":"/programming_notes/:2:0","tags":["server"],"title":"编程笔记","uri":"/programming_notes/"},{"categories":["编程感悟"],"content":"数据竞态 数据竞态发生在两个线程并发读写同一个变量并且至少其中一个是写入的时候。 避免数据竞态的三种方法： 不要修改变量。从不修改的数据结构和不可变的数据结构本质上是并发安全的，也不需要做任何同步。 避免从多个线程访问同一变量。 允许多个线程访问同一变量，但是同一时间只有一个线程可以访问。这种方法成为互斥机制。 ","date":"2019-02-23","objectID":"/programming_notes/:2:1","tags":["server"],"title":"编程笔记","uri":"/programming_notes/"},{"categories":["编程感悟"],"content":"消息队列 消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。 ——维基百科 异步处理 将耗时较长且不需要即使同步的操作放入消息队列，减少系统响应时间 解耦和 不同服务之间通过消息队列进行通信，只需要定义好消息的格式，服务之间不需要有联系 可靠性 可以通过对消费者的横向扩展，降低消息队列阻塞和单个消费者出现故障的风险 消息队列可以将接收到的消息存储到本地磁盘，这样就算程序或者消息队列挂掉，消息也能被重新加载 加入消息队列会增加系统的复杂度，只有当性能出现瓶颈的时候，可以引入消息队列对可以异步处理的耗时操作进行处理。 应用场景：广播、流量削峰和流量控制、日志处理（Kafka）、消息通讯（聊天室）等等 ","date":"2019-02-23","objectID":"/programming_notes/:3:0","tags":["server"],"title":"编程笔记","uri":"/programming_notes/"},{"categories":["编程感悟"],"content":"计算机本质 计算机领域最重要的三件事情：存储、计算和传输。 存储大、计算快、传输带宽大延迟低是不可能同时实现的。所以计算机技术一般都是牺牲其中一二，选择更重要的。 存储有关计算机原理，计算有关数据结构和算法，传输有关计算机网络，而三者结合便是计算机操作系统。 数据压缩是牺牲计算换来存储更小，传输更快 缓存对比硬盘是牺牲存储，换来计算更快，传输更少 ","date":"2019-02-23","objectID":"/programming_notes/:4:0","tags":["server"],"title":"编程笔记","uri":"/programming_notes/"},{"categories":["编程感悟"],"content":"泛型 ","date":"2019-02-23","objectID":"/programming_notes/:5:0","tags":["server"],"title":"编程笔记","uri":"/programming_notes/"},{"categories":["编程感悟"],"content":"作用 程序更加健壮：编译器在编译期间可以对类型进行检查，避免运行时出现类型转换异常 避免强制转换：不需要显式强制转换类型，代码更加简洁 参数化类型：算法复用，减少代码量 ","date":"2019-02-23","objectID":"/programming_notes/:5:1","tags":["server"],"title":"编程笔记","uri":"/programming_notes/"},{"categories":["编程感悟"],"content":"参考链接 分布式和集群的区别 ","date":"2019-02-23","objectID":"/programming_notes/:6:0","tags":["server"],"title":"编程笔记","uri":"/programming_notes/"},{"categories":["Go"],"content":"包 约定包名与导入路径的最后一个元素相同 math/rand 的包名为 rand ","date":"2019-01-14","objectID":"/go_mark/:1:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"函数 函数参数不是指针的话，即为值传递。 多个函数的已命名形参类型相同时，除最后一个类型外，其他的都可以省略 x int, y int x, y int ","date":"2019-01-14","objectID":"/go_mark/:2:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"函数的闭包 Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。闭包保证了函数内引用变量的生命周期和函数的活动时间相同。 func adder() func(int) int { sum := 0 -- 函数外部的变量 return func(x int) int { -- 闭包 sum += x return sum } } ","date":"2019-01-14","objectID":"/go_mark/:2:1","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"变量 ","date":"2019-01-14","objectID":"/go_mark/:3:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"短变量声明 在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。 函数外的每个语句都必须以关键字开始（var, const, func 等等），因此 := 结构不能在函数外使用。 ","date":"2019-01-14","objectID":"/go_mark/:3:1","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"基本类型 bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 byte // uint8 的别名 rune // int32 的别名，表示一个 Unicode 码点 float32 float64 complex64 complex128 // 复数类型：20+5i int, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。 ","date":"2019-01-14","objectID":"/go_mark/:4:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"零值 没有明确初始值的变量声明会被赋予它们的 零值。 数值类型零值为 0 布尔类型零值为 false 字符串的零值为 “\"(空字符串) ","date":"2019-01-14","objectID":"/go_mark/:5:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"常量 const Pi = 3.141592653589793 常量的声明与变量类似，只不过是使用 const 关键字。 常量可以是字符、字符串、布尔值或数值。 常量不能用 := 语法声明。 ","date":"2019-01-14","objectID":"/go_mark/:6:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"defer defer 语句会将函数推迟到外层函数返回之后执行。 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。 ","date":"2019-01-14","objectID":"/go_mark/:7:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"指针 类型 *T 是指向 T 类型值的指针。其零值为 nil。 var p *int \u0026 操作符会生成一个指向其操作数的指针。 i := 42 p = \u0026i * 操作符表示指针指向的底层值。 fmt.Println(*p) // 通过指针 p 读取 i *p = 21 // 通过指针 p 设置 i ","date":"2019-01-14","objectID":"/go_mark/:8:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"结构体 一个结构体（struct）就是一个字段的集合。 type Vertex struct { X int Y int } ","date":"2019-01-14","objectID":"/go_mark/:9:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"数组 类型 [n]T 表示拥有 n 个 T 类型的值的数组。数组的长度是其类型的一部分，因此数组不能改变大小。 var a [10]int ","date":"2019-01-14","objectID":"/go_mark/:10:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"切片 slice 类型 []T 表示一个元素类型为 T 的切片。 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔： 上标和下标均可省略，上标缺省值为 0，下标缺省值为 a 的长度 a[low : high] 它会选择一个半开区间，包括第一个元素，但排除最后一个元素。 切片并不存储任何数据，它只是描述了底层数组中的一段。 更改切片的元素会修改其底层数组中对应的元素。 与它共享底层数组的切片都会观测到这些修改。 ","date":"2019-01-14","objectID":"/go_mark/:11:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"零值 切片的零值是 nil。 nil 切片的长度和容量为 0 且没有底层数组。 ","date":"2019-01-14","objectID":"/go_mark/:11:1","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"长度和容量 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。 ","date":"2019-01-14","objectID":"/go_mark/:11:2","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"用 make 创建切片 切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。 make 函数会分配一个元素为零值的数组并返回一个引用了它的切片： a := make([]int, 5) // len(a)=5 要指定它的容量，需向 make 传入第三个参数： b := make([]int, 0, 5) // len(b)=0, cap(b)=5 ","date":"2019-01-14","objectID":"/go_mark/:11:3","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"向切片追加元素 func append(s []T, vs …T) []T append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。 append 的结果是一个包含原切片所有元素加上新添加元素的切片。 当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。 ","date":"2019-01-14","objectID":"/go_mark/:11:4","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"映射 map 映射将键映射到值。 映射的零值为 nil 。nil 映射既没有键，也不能添加键。 make 函数会返回给定类型的映射，并将其初始化备用。 m = make(map[string]int) ","date":"2019-01-14","objectID":"/go_mark/:11:5","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"修改映射 在映射 m 中插入或修改元素： m[key] = elem 获取元素： elem = m[key] 删除元素： delete(m, key) 通过双赋值检测某个键是否存在： elem, ok = m[key] 若 key 在 m 中，ok 为 true ；否则，ok 为 false。 若 key 不在映射中，那么 elem 是该映射元素类型的零值。 同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。 注 ：若 elem 或 ok 还未声明，你可以使用短变量声明： elem, ok := m[key] ","date":"2019-01-14","objectID":"/go_mark/:11:6","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"方法 为结构体类型实现方法即为类。 方法只是个带接收者参数的函数。 方法就是一类带特殊的 接收者 参数的函数。 方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。 接收者的类型定义和方法声明必须在同一包内；不能为其它包内定义的类型的接收者声明方法；也不能为内建类型（包括 int 之类的）声明方法。 可以为指针接收者声明方法。 这意味着对于某类型 T，接收者的类型可以用 *T 的文法。（此外，T 不能是像 *int 这样的指针。） type MyFloat float64 func (f MyFloat) Abs() float64 { // 方法 ... } type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { // 为值接收者声明方法 return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v *Vertex) Scale(f float64) { // 为指针接收者声明方法 v.X = v.X * f v.Y = v.Y * f } func main() { f := MyFloat(-math.Sqrt2) f.Abs() // 调用方法 } ","date":"2019-01-14","objectID":"/go_mark/:12:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"方法与指针重定向 带指针参数的函数必须接受一个指针；接受一个值作为参数的函数必须接受一个指定类型的值。 以指针为接收者的方法被调用时，接收者既能为值又能为指针；以值为接收者的方法被调用时，接收者既能为值又能为指针。 type Vertex struct { X, Y float64 } func (v *Vertex) Scale(f float64) { // 指针为接收者的方法 v.X = v.X * f v.Y = v.Y * f } func ScaleFunc(v *Vertex, f float64) { // 带指针参数的函数 v.X = v.X * f v.Y = v.Y * f } func (v Vertex) Abs() float64 { // 以值为接收者的方法 return math.Sqrt(v.X*v.X + v.Y*v.Y) } func AbsFunc(v Vertex) float64 { // 以值为参数的函数 return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} v.Scale(2) // OK (\u0026v).Scale(2) // OK ScaleFunc(v, 10) // 编译错误 ScaleFunc(\u0026v, 10) // OK v.Abs() // OK (\u0026v).Abs() // OK AbsFunc(v) // OK AbsFunc(\u0026v) // 编译错误 fmt.Println(v, p) } ","date":"2019-01-14","objectID":"/go_mark/:12:1","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"选择值或指针作为接收者 使用指针接收者的原因有二： 方法能够修改其接收者指向的值。 这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。 ","date":"2019-01-14","objectID":"/go_mark/:12:2","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"接口 接口类型是由一组方法签名定义的集合。 接口类型的变量可以保存任意实现了这些方法的值。 type I interface { Abs() float64 } // 类型 F 实现了接口 I type F float64 func (f MyFloat) Abs() float64 { if f \u003c 0 { return float64(-f) } return float64(f) } // 类型 *T 实现了接口 I type V struct { x, y float64 } func (v *V) Abs() float64 { return math.Sqrt(v.x * v.x + v.y * v.y) } func main() { var i I f := F(math.Sqrt2) v := V{3, 4} a = f // OK a = \u0026v // OK a = v // 编译错误，Vertex 没有实现接口 I var a I = V{3, 4} // OK } ","date":"2019-01-14","objectID":"/go_mark/:13:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"接口值 接口也是值。它们可以像其它值一样传递。接口值可以用作函数的参数或返回值。 在内部，接口值可以看做包含值和具体类型的元组： (value, type) 接口值保存了一个具体底层类型的具体值。 接口值调用方法时会执行其底层类型的同名方法。 func main { var i I = F(-1) fmt.Printf(\"%v, %T\", i, i) // -1, main.F } ","date":"2019-01-14","objectID":"/go_mark/:13:1","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"底层值为 nil 的接口值和 nil 接口值 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。 注意: 保存了 nil 具体值的接口其自身并不为 nil。 nil 接口值既不保存值也不保存具体类型。 为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。 type I interface { M() } type T struct { } func (t *T) M() { } func main() { var i I fmt.Printf(\"(%v, %T)\\n\", i, i) // \u003cnil\u003e, \u003cnil\u003e i.M() // 编译错误 var t *T i = t fmt.Printf(\"(%v, %T)\\n\", i, i) // \u003cnil\u003e, *main.T i.M() // OK } ","date":"2019-01-14","objectID":"/go_mark/:13:2","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"空接口 指定了零个方法的接口值被称为 空接口： interface{} 空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。） 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。 ","date":"2019-01-14","objectID":"/go_mark/:13:3","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"类型断言 类型断言提供了访问接口值底层具体值的方式。 t := i.(T) 该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。 若 i 并未保存 T 类型的值，该语句就会触发一个 panic。 为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。 t, ok := i.(T) 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。 否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生 panic。 注意：这种语法和读取一个 map 映射时的相同之处。 ","date":"2019-01-14","objectID":"/go_mark/:13:4","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"类型选择 类型选择是一种按顺序从几个类型断言中选择分支的结构。 类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。 switch v := i.(type) { case T: // v 的类型为 T case S: // v 的类型为 S default: // 没有匹配，v 与 i 的类型相同, 即一个包含值和具体类型的接口值 } 类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。 此选择语句判断接口值 i 保存的值类型是 T 还是 S。在 T 或 S 的情况下，变量 v 会分别按 T 或 S 类型保存 i 拥有的值。在默认（即没有匹配）的情况下，变量 v 与 i 的接口类型和值相同。 ","date":"2019-01-14","objectID":"/go_mark/:13:5","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go"],"content":"并发 ","date":"2019-01-14","objectID":"/go_mark/:14:0","tags":["Go"],"title":"Go 笔记","uri":"/go_mark/"},{"categories":["Go","manual"],"content":"安装 Go 语言支持以下系统： Linux FreeBSD Mac OS X（也称为 Darwin） Windows 安装下载地址 操作系统 包名 Windows go1.x.windows-amd64.msi Linux go1.x.linux-amd64.tar.gz Mac go1.x.darwin-amd64-osx10.8.pkg FreeBSD go1.x.freebsd-amd64.tar.gz ","date":"2019-01-12","objectID":"/go_vscode/:1:0","tags":["Go","VSCode"],"title":"VSCode 配置 Go 环境","uri":"/go_vscode/"},{"categories":["Go","manual"],"content":"UNIX/Linux/Mac OS X, 和 FreeBSD 安装 下载二进制包：go1.4.linux-amd64.tar.gz。 将下载的二进制包解压至 /usr/local目录。 tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz 将 /usr/local/go/bin 目录添加至PATH环境变量 export PATH=$PATH:/usr/local/go/bin ","date":"2019-01-12","objectID":"/go_vscode/:1:1","tags":["Go","VSCode"],"title":"VSCode 配置 Go 环境","uri":"/go_vscode/"},{"categories":["Go","manual"],"content":"Windows 系统下安装 Windows 下可以使用 .msi 后缀(在下载列表中可以找到该文件，如go1.4.2.windows-amd64.msi)的安装包来安装。 默认情况下.msi文件会安装在 c:\\Go 目录下。你可以将 c:\\Go\\bin 目录添加到 PATH 环境变量中。添加后你需要重启命令窗口才能生效。 ","date":"2019-01-12","objectID":"/go_vscode/:1:2","tags":["Go","VSCode"],"title":"VSCode 配置 Go 环境","uri":"/go_vscode/"},{"categories":["Go","manual"],"content":"安装测试 创建工作目录 C:\u003eGo_WorkSpace。 文件名: test.go，代码如下： package main import \"fmt\" func main() { fmt.Println(\"Hello World!\") } 使用 go 命令执行以上代码输出结果如下： C:\\Go_WorkSpace\u003ego run test.go Hello, World! ","date":"2019-01-12","objectID":"/go_vscode/:1:3","tags":["Go","VSCode"],"title":"VSCode 配置 Go 环境","uri":"/go_vscode/"},{"categories":["Go","manual"],"content":"VSCode 配置 go 下载插件 Go 插件特性包括： Colorization 代码着彩色 Completion Lists 代码自动完成（使用gocode） Snippets 代码片段 Quick Info 快速提示信息（使用godef） Goto Definition 跳转到定义（使用godef） Find References 搜索参考引用（使用go-find-references） File outline 文件大纲（使用go-outline） Workspace symbol search 工作区符号搜索（使用 go-symbols） Rename 重命名（使用gorename） Build-on-save 保存构建（使用go build和go test） Format 代码格式化（使用goreturns或goimports或gofmt） Add Imports 添加引用（使用 gopkgs） Debugging 调试代码（使用delve） ","date":"2019-01-12","objectID":"/go_vscode/:2:0","tags":["Go","VSCode"],"title":"VSCode 配置 Go 环境","uri":"/go_vscode/"},{"categories":["Go","manual"],"content":"安装插件 Ctrl+Shift+p 打开控制面板 Go:Install/Update Tools 这时候一般会出现安装报错，只有部分插件能够安装成功 ","date":"2019-01-12","objectID":"/go_vscode/:2:1","tags":["Go","VSCode"],"title":"VSCode 配置 Go 环境","uri":"/go_vscode/"},{"categories":["Go","manual"],"content":"报错原因 在安装go插件时，会自动更新很多依赖库文件，都是从Github更新下来，但是因为Github的文件中，多有应用go官网中的文件，因为网络缘故，不能直接下载，导致安装失败。 ","date":"2019-01-12","objectID":"/go_vscode/:2:2","tags":["Go","VSCode"],"title":"VSCode 配置 Go 环境","uri":"/go_vscode/"},{"categories":["Go","manual"],"content":"解决方法 使用git软件的Git Bash Here 命令行窗口进行（要求使用，否则git clone时无法下载插件），进入安装go时创建的GOPATH目录（“此电脑-\u003e属性-\u003e高级系统设置-\u003e高级-\u003e环境变量-\u003e系统变量”中的GOPATH目录）： 创建github.com插件目录及下载插件 cd $GOPATH/src mkdir github.com cd $GOPATH/src/github.com mkdir acroca cweill derekparker go-delve josharian karrick mdempsky pkg ramya-rao-a rogpeppe sqs uudashr cd $GOPATH/src/github.com/acroca git clone https://github.com/acroca/go-symbols.git cd $GOPATH/src/github.com/cweill git clone https://github.com/cweill/gotests.git cd $GOPATH/src/github.com/derekparker git clone https://github.com/derekparker/delve.git cd $GOPATH/src/github.com/go-delve git clone https://github.com/go-delve\\delve.git cd $GOPATH/src/github.com/josharian git clone https://github.com/josharian/impl.git cd $GOPATH/src/github.com/karrick git clone https://github.com/karrick/godirwalk.git cd $GOPATH/src/github.com/mdempsky git clone https://github.com/mdempsky/gocode.git cd $GOPATH/src/github.com/pkg git clone https://github.com/pkg/errors.git cd $GOPATH/src/github.com/ramya-rao-a git clone https://github.com/ramya-rao-a/go-outline.git cd $GOPATH/src/github.com/rogpeppe git clone https://github.com/rogpeppe/godef.git cd $GOPATH/src/github.com/sqs git clone https://github.com/sqs/goreturns.git cd $GOPATH/src/github.com/uudashr git clone https://github.com/uudashr/gopkgs.git 创建golang.org插件目录及下载插件 cd $GOPATH/src mkdir -p golang.org/x cd golang.org/x git clone https://github.com/golang/tools.git git clone https://github.com/golang/lint.git 手动安装插件 cd $GOPATH/src go install github.com/mdempsky/gocode go install github.com/uudashr/gopkgs/cmd/gopkgs go install github.com/ramya-rao-a/go-outline go install github.com/acroca/go-symbols go install github.com/rogpeppe/godef go install github.com/sqs/goreturns go install github.com/derekparker/delve/cmd/dlv go install github.com/cweill/gotests go install github.com/josharian/impl go install golang.org/x/tools/cmd/guru go install golang.org/x/tools/cmd/gorename go install golang.org/x/lint/golint 至此，插件安装成功，重启 VSCode 即可编写 Go。 ","date":"2019-01-12","objectID":"/go_vscode/:2:3","tags":["Go","VSCode"],"title":"VSCode 配置 Go 环境","uri":"/go_vscode/"},{"categories":["Go","manual"],"content":"后续更新，更好的解决方案，一键解决 go get golang.org/x 包失败 go mod 和 goproxy ","date":"2019-01-12","objectID":"/go_vscode/:3:0","tags":["Go","VSCode"],"title":"VSCode 配置 Go 环境","uri":"/go_vscode/"},{"categories":["manual"],"content":"文件属性 drwxr-xr-x 4 root root 4096 Dec 12 10:20 log 文件的第一个属性代表的意思 [d] : 目录 [-] : 文件 [l] : 链接文档 [b] : 装置文件里的可供存储的接口设备（可随机存取装置） [c] : 装置文件里的串行端口设备，例如键鼠（一次性读取装置） 接下来是以三个为一组的权限说明 [rwx] 三个权限位置不变，无权限则用 [-] 代替 r : 可读(read) w : 可写(write) x : 可执行(execute) drwxr-xr-x 下划线的代表属主权限 drwxr-xr-x 下划线的代表与属主同组的其他用户权限 drwxr-xr-x 下划线的代表其他用户权限 第一个 root 表示文件所有者 第二个 root 表示文件所属的组 4096 表示文件大小 然后是文件最后访问/修改的日期 最后的 log 则代表文件名 注：对于 root 用户，一般情况下，文件的权限对其不起作用 ","date":"2019-01-05","objectID":"/linux_base/:1:0","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"更改权限 更改文件属主，同时更改文件属组 chown [-R] 属主名 文件名 chown [-R] 属主名:属组名 文件名 更改文件属组 chgrp [-R] 属组名 文件名 更改文件读写权限 chmod [-R] ugo 文件名 e.g. chmod 754 log u(user), g(group), o(other) r : 4, w : 2, x : 1 如上面例子，754 表示的权限为 rwxr-xr– ","date":"2019-01-05","objectID":"/linux_base/:2:0","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"处理目录命令 ","date":"2019-01-05","objectID":"/linux_base/:3:0","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"ls (列出目录) [root@www ~]# ls [-aAdfFhilnrRSt] 目录名称 [root@www ~]# ls [–color={never,auto,always}] 目录名称 [root@www ~]# ls [–full-time] 目录名称 ll 表示 ls -l -a ：全部的文件，连同隐藏档（开头为.的文件）一起列出来（常用） -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据(常用) ","date":"2019-01-05","objectID":"/linux_base/:3:1","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"cd (切换目录) cd [相对路径或绝对路径] / 根目录 ~ 家目录 . 当前目录 .. 上级目录 ","date":"2019-01-05","objectID":"/linux_base/:3:2","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"pwd (显示目前所在的目录) [root@www ~]# pwd [-P] -P ：显示出确实的路径，而非使用连结 (link) 路径。 ","date":"2019-01-05","objectID":"/linux_base/:3:3","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"mkdir (创建新目录) mkdir [-mp] 目录名称 -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色 -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来 ","date":"2019-01-05","objectID":"/linux_base/:3:4","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"rmdir (删除空的目录) rmdir [-p] 目录名称 -p ：连同上一级『空的』目录也一起删除 ","date":"2019-01-05","objectID":"/linux_base/:3:5","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"cp (拷贝文件或目录) [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination) [root@www ~]# cp [options] source1 source2 source3 …. directory -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身 -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次 -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身 -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用) -r：递归持续复制，用於目录的复制行为；(常用) -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件 -u：若 destination 比 source 旧才升级 destination ","date":"2019-01-05","objectID":"/linux_base/:3:6","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"rm (移除文件或目录) rm [-fir] 文件或目录 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息 -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ ","date":"2019-01-05","objectID":"/linux_base/:3:7","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"mv (移动文件与目录，或修改名称) [root@www ~]# mv [-fiu] source destination [root@www ~]# mv [options] source1 source2 source3 …. directory -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) ","date":"2019-01-05","objectID":"/linux_base/:3:8","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"文件内容查看 ","date":"2019-01-05","objectID":"/linux_base/:4:0","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"cat 从第一行开始显示文件内容 cat [-AbEnTv] -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已 -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号 -E ：将结尾的断行字节 $ 显示出来 -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同 -T ：将 [tab] 按键以 ^I 显示出来 -v ：列出一些看不出来的特殊字符 ","date":"2019-01-05","objectID":"/linux_base/:4:1","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"tac 文件内容从最后一行倒序显示，与 cat 正好相反 ","date":"2019-01-05","objectID":"/linux_base/:4:2","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"nl 显示行号 nl [-bnw] 文件 -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n) -b t ：如果有空行，空的那一行不要列出行号(默认值) -n ：列出行号表示的方法，主要有三种： -n ln ：行号在荧幕的最左方显示 -n rn ：行号在自己栏位的最右方显示，且不加 0 -n rz ：行号在自己栏位的最右方显示，且加 0 -w ：行号栏位的占用的位数 ","date":"2019-01-05","objectID":"/linux_base/:4:3","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"more 一页一页翻动 在 more 程序运行过程中，可以做下面操作 空白键(space) 代表向下翻一页 Enter 代表向下翻『一行』 /字串 代表在这个显示的内容当中，向下搜寻『字串』这个关键字 :f 立刻显示出档名以及目前显示的行数 q 代表立刻离开 more ，不再显示该文件内容 b 或 [ctrl]-b 代表往回翻页，不过这动作只对文件有用，对管线无用 ","date":"2019-01-05","objectID":"/linux_base/:4:4","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"less 一页一页翻动 空白键 向下翻动一页 [pagedown] 向下翻动一页 [pageup] 向上翻动一页 /字串 向下搜寻『字串』的功能 ?字串 向上搜寻『字串』的功能 n 重复前一个搜寻 (与 / 或 ? 有关！) N 反向的重复前一个搜寻 (与 / 或 ? 有关！) q 离开 less 这个程序 ","date":"2019-01-05","objectID":"/linux_base/:4:5","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"head 取出文件前面几行 head [-n number] 文件 -n ：后面接数字，代表显示几行的意思 ","date":"2019-01-05","objectID":"/linux_base/:4:6","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"tail 取出文件后面几行 tail [-n number] 文件 -n ：后面接数字，代表显示几行的意思 -f ：表示持续侦测后面所接的档名，要等到按下[ctrl+c]才会结束tail的侦测 ","date":"2019-01-05","objectID":"/linux_base/:4:7","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"常用光标跳转快捷键 ctrl+(←/←) : 单词之间跳转 ctrl+a : 跳转到行首 ctrl+e : 跳转到行末 ctrl+u : 删除光标前的命令 ctrl+k : 删除光标后的命令 ctrl+w : 删除当前单词 ctrl+d : 删除光标后的一个字符 ctrl+y : 撤销删除操作 ctrl+l : 清屏 ","date":"2019-01-05","objectID":"/linux_base/:5:0","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"vi/vim vi 有三种基本的工作模式： 命令模式(Command Mode) 输入模式(Input Mode) 底线命令模式(Last Line Mode) ","date":"2019-01-05","objectID":"/linux_base/:6:0","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"命令模式 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 n n 为数字。光标向下移动 n 行(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 以下 5 个移动光标操作可以与 d，y 配合，做删除复制操作 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set * nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) 删除复制和粘贴([n]代表选填) d0, d$, dG, d1G, dgg 删除当前到目标光标处或目标行 y0, y$, yG, y1G, ygg 复制当前到目标光标处或目标行 [n]dd 向下删除所在[及向下 n]行 [n]yy 向下复制所在[及向下 n]行 [n]x 向后删除一个或 n 个字符 [n]X 向前删除一个或 n 个字符 [n]p 将复制内容粘贴在下一行 1[n] 次 [n]P 将复制内容粘贴在上一行 1[n] 次 [n]J 将光标所在行与下一行的数据结合成同一行 [n]c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] [n]u 撤销操作 [n]Ctrl+r 回退操作 . 重复前一个操作或动作 ","date":"2019-01-05","objectID":"/linux_base/:6:1","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"命令模式切换到输入模式 进入输入模式(Insert mode) i 从当前光标出输入 I 从当前所在行的第一个非空格符出开始输入 a 从当前光标所在的下一个字符处开始输入 A 从当前光标所在行的最后一个字符处开始输入 o 在当前光标所在行的下一行输入新的一行 O 在当前光标所在行的上一行输入新的一行 进入取代模式(Replace mode) r 只会取代光标所在的那一个字符一次 R 会一直取代光标所在字符，直到按下 ESC 为止 退出输入模式 ESC 退出输入模式，回到命令模式 ","date":"2019-01-05","objectID":"/linux_base/:6:2","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"命令模式切换到底线命令模式的可用操作 :w 存盘 :q 离开 vi :q! 强制离开不存盘 :wq 存盘后离开 vi ZZ 若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开 :w[filename] 将编辑的数据储存成另一个档案（类似另存新档） :r[filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w[filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ 其他操作 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ ","date":"2019-01-05","objectID":"/linux_base/:6:3","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"vi 批量添加注释 方法一 ：块选择模式 批量注释： Ctrl + v 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 I 进入行首插入模式输入注释符号如 // 或 #，输入完毕之后，按两下 ESC，Vim 会自动将你选中的所有行首都加上注释，保存退出完成注释。 取消注释： Ctrl + v 进入块选择模式，选中你要删除的行首的注释符号，注意 // 要选中两个，选好之后按 d 即可删除注释，ESC 保存退出。 方法二: 替换命令 批量注释。 使用下面命令在指定的行首添加注释。 使用名命令格式： :起始行号,结束行号s/^/注释符/g（注意冒号）。 取消注释： 使用名命令格式： :起始行号,结束行号s/^注释符//g（注意冒号）。 例子： 1、在 10 - 20 行添加 // 注释 :10,20s#^#//#g 2、在 10 - 20 行删除 // 注释 :10,20s#^//##g 3、在 10 - 20 行添加 # 注释 :10,20s/^/#/g 4、在 10 - 20 行删除 # 注释 :10,20s/#//g ","date":"2019-01-05","objectID":"/linux_base/:6:4","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["manual"],"content":"参考链接 神奇高效的 linux 命令行 Linux 工具快速教程 ","date":"2019-01-05","objectID":"/linux_base/:7:0","tags":["Linux"],"title":"Linux 命令","uri":"/linux_base/"},{"categories":["skynet"],"content":"内存问题 skynet 服务在处理新消息时，是通过创建新协程来处理的（见co_create），虽然协程会被重复利用，但在当前版本下，这种不断创建协程来消息的方式本身存在不稳定因素： 协程只增加不减少，意味过了某个并发高峰后内存不会降下来。 创建协程也有一定开销，容易触发GC，也占用内存，协程的数量规模不容易控制 如果解决第1点，最槽糕的情况是，不断要创建协程，不断要销毁协程，频繁触发gc ","date":"2019-01-04","objectID":"/skynet_hidden_trouble/:1:0","tags":["skynet"],"title":"skynet 缺陷和隐患","uri":"/skynet_hidden_trouble/"},{"categories":["skynet"],"content":"同步问题 当一个服务 call 其他服务时，当前协程会挂起，但是当前服务还可以继续接受并处理其他消息。如果中间有多个协程更改同一个数据的话，不做同步处理是无法确定这个数据的。 解决方法：加多一个 state 的标识和一个协程列表，操作执行时，将 state 置为 true，其他协程判断 state == true 时将自己加到协程列表中，然后 skynet.wait。在操作执行完后，重置 state，然后遍历协程列表依次 skynet.wakeup(co)，最后将协程列表清空。 local state = nil local wait_co_list = {} if state == nil then state = true do something yield state = nil if next(wait_co_list) then for i, co in ipairs(wait_co_list) do skynet.waitup(co) end wait_co_list = {} end else local co = corouine.running() table.insert(wait_co_list, co) skynet.wait(co) end ","date":"2019-01-04","objectID":"/skynet_hidden_trouble/:2:0","tags":["skynet"],"title":"skynet 缺陷和隐患","uri":"/skynet_hidden_trouble/"},{"categories":["manual"],"content":"安装 下载地址：MySQL dwonload 所有平台都可以在这里选择需要的 MySQL Community Server 版本及对应的平台 具体安装方法参考：MySQL install windows 解压下载的文件，在解压的文件夹下创建 my.ini 配置文件，编辑配置： [mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 basedir=E:\\mysql # 设置mysql数据库的数据的存放目录 datadir=E:\\mysql\\Data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8 用管理员身份打开 cmd 命令行工具，切换目录 E: cd mysql\\bin 安装时可以为 mysql 服务创建名称，方便建立多个 mysql 服务不冲突，否则默认 mysql 服务名为 mysql mysqld install [sql server name] 初始化数据库，执行完成会输出 root 用户的初始默认密码，复制后可以在要求输入密码时粘贴 mysqld --initialize --console 启动 net start mysql 登陆 MySQL mysql -h 主机名 -u 用户名 -p -h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0。1)该参数可以省略; -u : 登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 如果登陆本机的 mysql 数据库，直接输入，提示输入密码，然后将之前的默认初始密码复制粘贴输入 mysql -u root -p Enter password: ","date":"2019-01-04","objectID":"/mysql/:1:0","tags":["MySQL"],"title":"Mysql","uri":"/mysql/"},{"categories":["manual"],"content":"其他命令 mysql 命令一定要在结尾加 ; 卸载 mysqld remove 关闭 mysql 服务 net stop mysql 修改用户密码 mysql\u003ealter user ‘root’@‘localhost’ identified by ‘newpassword’; 列出所有数据库 mysql\u003eshow databases; 创建数据库 mysql\u003ecreate database dbname; 切换数据库 mysql\u003euse dbname; Database changed 导入 sql 文件 mysql\u003esource e:\\mysql\\sql.sql 列出所有表 mysql\u003eshow tables; 显示数据表结构 mysql\u003edescribe tablename; 删除数据库和数据表 mysql\u003edrop database dbname; mysql\u003edrop table tablename; ","date":"2019-01-04","objectID":"/mysql/:2:0","tags":["MySQL"],"title":"Mysql","uri":"/mysql/"},{"categories":["manual"],"content":"创建表 创建数据表需要以下信息 : 表名 表字段名 定义各个表字段 CREATE TABLE table_name (column_name column_type); 创建数据表 tbl : CREATE TABLE IF NOT EXISTS `tbl` ( `id` INT UNSIGNED AUTO_INCREMENT, `title` VARCHAR(100) NOT NULL, `author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `id` ) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 设置字段属性为 NOT NULL，如果插入的时候该字段的数据为 NULL 时，就会报错 AUTO_INCREMENT 定义列为自增的属性，一般用于主键，数值会自动加 1 PRIMARY KEY 用于定义列为主键，也可以使用多列定义主键，列间用逗号隔开 ENGINE 设置存储引擎，CHARSET 设置编码 ","date":"2019-01-04","objectID":"/mysql/:2:1","tags":["MySQL"],"title":"Mysql","uri":"/mysql/"},{"categories":["manual"],"content":"删除表 DROP TABLE table_name; ","date":"2019-01-04","objectID":"/mysql/:2:2","tags":["MySQL"],"title":"Mysql","uri":"/mysql/"},{"categories":["manual"],"content":"插入数据 可以插入一行或者多行数据 INSERT INFO table_name ( field1, field2, field3, … ) VALUES ( value1, value2, value3, … ), ( value1, value2, value3, … ), … ( value1, value2, value3, … ); ","date":"2019-01-04","objectID":"/mysql/:2:3","tags":["MySQL"],"title":"Mysql","uri":"/mysql/"},{"categories":["manual"],"content":"查询数据 SELECT column_name, column_name FROM table_name [, table_name] [WHERE Clause] [LIMIT N] [OFFSET M] SELECT *: 返回所有记录 LIMIT N: 返回 N 条记录 OFFSET M: 跳过 M 条记录，默认 M=0 LIMIT N,M: 相当于 LIMIT M OFFSET N，从第 N 条记录开始，返回 M 条记录 UPDATE 语句 UPDATE table_name SET field1=new_value1, field2=new_value2 [WHERE Clause] DELETE 语句 DELETE FROM table_name [WHERE Clause] 如果没有指定 WHERE 语句，表中的所有记录将被删除 drop, truncate, delete 的区别 不需要表了，用 drop 保留表结构，删除所有记录，用 truncate 删除部分记录（always with a WHERE clause），用 delete delete 是 DML 语句，操作完不想提交事务可以回滚 truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚 执行速度：drop \u003e truncate \u003e delete LIKE 子句 与 WHERE 搭配使用，进行模糊匹配，与 % 和 _ 结合使用 % 匹配多个任意字符，_ 匹配一个任意字符 ","date":"2019-01-04","objectID":"/mysql/:2:4","tags":["MySQL"],"title":"Mysql","uri":"/mysql/"},{"categories":["skynet"],"content":"skynet attempt to yield across a C-call boundary 错误问题 ","date":"2018-12-14","objectID":"/skynet_attempt_to_yield_across_a_ccall_boundary/:1:0","tags":["skynet"],"title":"skynet attempt to yield across a C-call boundary 错误问题","uri":"/skynet_attempt_to_yield_across_a_ccall_boundary/"},{"categories":["skynet"],"content":"解决方法 检查出问题的服务是否 require datasheet/multicast/cluser/sharedata/...，如果有，则必须在 skynet.start 之前先 require 一下。 ","date":"2018-12-14","objectID":"/skynet_attempt_to_yield_across_a_ccall_boundary/:1:1","tags":["skynet"],"title":"skynet attempt to yield across a C-call boundary 错误问题","uri":"/skynet_attempt_to_yield_across_a_ccall_boundary/"},{"categories":["skynet"],"content":"原因 导致 yield across a C-call boundary 的原因，C(sknet framwork) -\u003e lua(skynet service) -\u003e C -\u003e lua 最后这个 lua 里如果调用了 yield 就会产生 这里 require 是一个 C 函数 skynet.init 就是为了避免你在 require 阶段运行阻塞代码， https://github.com/cloudwu/skynet/blob/master/lualib/skynet.lua#L588-L600 把它推迟到 skynet.start 再运行 除非你在别的地方破坏了这个行为，让 https://github.com/cloudwu/skynet/blob/master/lualib/skynet.lua#L602 不小心运行了。 上面云风的意思就是在 C 函数里调用了 coroutine.yield()。 为什么在类似 require “datasheet” 时会调用到 yield 呢？ -- datasheet/init.lua skynet.init(function() datasheet_svr = service.query \"datasheet\" end) skynet.init 的作用 如果你想在 skynet.start 注册的函数之前做点什么，可以调用 skynet.init。这通常用于 lua 库的编写。如果你需要编写的服务在引用你的库的时候，事先调用一些 skynet 阻塞 API，就可以用 skynet.init 把这些工作注册在 start 之前 -- skynet.lua local init_func = {} function skynet.init(f, name) assert(type(f) == \"function\") if init_func == nil then -- 重点 f() else table.insert(init_func, f) if name then assert(type(name) == \"string\") assert(init_func[name] == nil) init_func[name] = f end end end 在调用到 skynet.init 时，如果 init_func 为 nil，就会直接执行 f()，而不是把它放到 init_func 队列里等待执行 而 skynet.init 这个函数是暴露在最外层的，即在 require 时就会被调用，如果 init_func 为 nil，就会直接执行 f()，若 f() 内有 yeild，就会报错。 那么 init_func 什么时候会是 nil 呢？ -- skynet.lua -- 此函数会在 skynet.start 指定的函数调用前被调用 local function init_all() print(debug.traceback()) local funcs = init_func init_func = nil -- 在此处被置为空 if funcs then for _, f in ipairs(funcs) do f() end end end 也就是说，在执行 skynet.start 之后，再去 require 上面所说的那些文件，就会调用到 skynet.init，直接执行到其中的函数。 这里的设计思路是：服务已经启动，init_func 的执行时机过去了，于是就直接执行了其中的函数。但是 skynet 中很多模块都在 skynet.init 里做一些查询地址之类的操作，这些操作会调用到 skynet.call，那么就会 yield。这就相当与把 skynet.call 直接暴露在最外面，require 就会直接执行到，那当然会报错。 ","date":"2018-12-14","objectID":"/skynet_attempt_to_yield_across_a_ccall_boundary/:1:2","tags":["skynet"],"title":"skynet attempt to yield across a C-call boundary 错误问题","uri":"/skynet_attempt_to_yield_across_a_ccall_boundary/"},{"categories":["skynet"],"content":"解决方法 既然在 skynet.start 之后不能调用 skynet.init 了，那我们就在 skynet.start 之前调用，也就是把要用到的这类模块（含有这种代码：skynet.init(function() skynet.call(…)end))，统统在服务入口文件的最上方 require 一遍。 只要保证 require datasheet/cluster/multicast 在 skynet.start 这行代码之前，就不会有问题了。 ","date":"2018-12-14","objectID":"/skynet_attempt_to_yield_across_a_ccall_boundary/:2:0","tags":["skynet"],"title":"skynet attempt to yield across a C-call boundary 错误问题","uri":"/skynet_attempt_to_yield_across_a_ccall_boundary/"},{"categories":["Lua"],"content":"Lua 字符串与正则表达式 ","date":"2018-12-07","objectID":"/lua_regularization/:1:0","tags":["Lua"],"title":"Lua 正则表达式","uri":"/lua_regularization/"},{"categories":["Lua"],"content":"Lua字符串匹配 与正则相关的函数 str = “{1:[1,2,3],2:{idx2:2,level:60,reward_idx:2001,ring:100},test:{1:100,2:200}}” string.find(s, pattern[, init[, plaub]]) 在字符串 s 中匹配 pattern，如果匹配成功，则返回第一个匹配到的子串的起始索引和结束索引，如果 pattern 中有分组，那么分组匹配的内容也会接在两个索引值后面返回；如果匹配失败则返回 nil。 第三个可选参数 init 指明从哪里开始搜索，默认值为1，可以是负值。 第四个可选参数 plain 为true 时，关闭模式匹配机制，pattern 作为普通字符串进行匹配。 string.find(str, ‘1,2,3’) 5 9 string.find(str, ‘%a+') 15 17 string.find(str, ‘(%d+),(%d+),(%d+)') 5 9 “1” “2” “3” string.find(str, ‘%d’, 1, true) nil string.match(s, pattern[, init]) 在字符串 s 中匹配 pattern，如果匹配成功，若 pattern 没有分组，则返回第一个匹配到的子串，若有分组，则依次返回各个匹配的分组；匹配失败则返回 nil。 第三个可选参数 init 指明从哪里开始搜索，默认值为1，可以是负值。 string.match(str, ‘%d+,%d+,%d+') “1,2,3” string.match(str, ‘(%d+)(:)([[]%d+)') “1” “:” “[1” string.match(str, ‘((%d+)(:)([[]%d+))') “1:[1” “1” “:” “[1” string.gmatch(s, pattern) 返回一个迭代器函数，每次调用迭代器，会返回下一个匹配到的子串，如果 pattern 中有分组，则返回的是子串对应的分组。 对这个函数来说，匹配模板前开始的 ‘^’ 不会当成锚点，这样会阻止迭代。 for s, a in string.gmatch(‘Hanazawa Kana’, ‘(a(%a)a)') do print(s, a) end “ana” “n” “awa” “w” “ana” “n” 注意：‘ana’ 匹配成功后，接下来的匹配从 ‘z’ 开始，导致 ‘z’ 没有被正确匹配到。 string.gsub(s, pattern, repl[, n]) 将字符串 s 中所有（或者可选参数前 n 个）pattern 替换成 repl，返回替换后的字符串和替换的次数。 如果 repl 是一个字符串，则把这个字符串作为替换品。字符 % 是一个转义符：repl 中所有形式为 %d 的串表示第 d 个捕获到的子串，d 可以是1到9，%0 表示整个匹配，%% 表示单个 %。 如果 repl 是表，每次匹配时会用第一个捕获作为建去查找表。 如果 repl 是函数，则每次匹配时会调用函数，所有捕获到的子串依次作为参数传入。 将 json 字符串转成 lua 字符串 str = string.gusb(str, “[[]”, “{\") str = string.gsub(str, “]”, “}\") str = string.gusb(str, “([{,])(%d+):”, “%1[%2]=\") str = string.gsub(str, “([{,])([%w_]+):”, “%1%2=\") print(str) “{[1]={1,2,3},[2]={idx2=2,level=60,reward_idx=2001,ring=100},test={[1]=100,[2]=200}” load(“return \" .. str)() ","date":"2018-12-07","objectID":"/lua_regularization/:1:1","tags":["Lua"],"title":"Lua 正则表达式","uri":"/lua_regularization/"},{"categories":["Lua"],"content":"正则表达式 字符 描述 普通字符 除去%.^$*+-?的字符，匹配字符本身 . 匹配任意字符 % 转义字符，当后面的字符是特殊字符时，还原特殊字符的愿意。% 和一些特定字母组合构成 lua 的预定义字符集。% 和数字 1~9 组合表示之前捕获的分组 […] 字符集，匹配一个包含于集合内的串，[…] 中的特殊字符表示原意 […-…] - 表示 ASCII 码在它前一个字符到它后一个字符之间的所有字符 [^…] 不在 … 中的字符集合 预定义字符集 %s 空白符[\\r\\n\\t\\v\\f] %p 标点符号 %c 控制符号 %w 字母数字 [a-zA-Z0-9] %a 字母 [a-zA-Z] %l 小写字母 [a-z] %u 大写字母 [A-Z] %d 数字 [0-9] %x 16进制数 [0-9a-fA-F] %z ASCII 码是 0 的字符 重复(数量词) * 表示前一个字符出现 0 到多次 + 表示前一个字符出现 1 到多次 ? 表示前一个字符出现 0 或 1 次 - 表示前一个字符出现 0 到多次，与 * 不同的是会匹配尽可能短的串 分组/捕获 (…) 表达式中用 () 包围的字符串作为一个分组，分组从左到右，组序号从 1 开始递增，空的捕获 () 将捕获到当前字符串的位置（是一个数字）。 边界匹配（属于零宽断言） ^ 在模式最前面加 ^ 匹配字符串开头，出现在其它位置没有特殊含义 $ 在模式最后面加 $ 匹配字符串结尾，出现在其它位置没有特殊含义 %b %bxy 匹配 xy 对，x，y 是两个表示原本意义的字符，匹配到的串以 x 开始 y 结束，且其中 x 和 y 保持平衡。即这个字符从左到右开始计数，遇 x 就 +1，遇 y 就 -1，到最终结束的 y 处是第一个计数到 0 的 y。%b() 可以匹配到括号平衡的表达式。 %f[…] 边界模式。会匹配到一个处于 … 内某个字符之前的一个空串，且这个位置的前一个字符不属于 …。 ","date":"2018-12-07","objectID":"/lua_regularization/:1:2","tags":["Lua"],"title":"Lua 正则表达式","uri":"/lua_regularization/"},{"categories":["Lua"],"content":"参考链接 Lua 5.3 参考手册 ","date":"2018-12-07","objectID":"/lua_regularization/:2:0","tags":["Lua"],"title":"Lua 正则表达式","uri":"/lua_regularization/"},{"categories":["manual"],"content":"Visual Studio Code 使用手册 ","date":"2018-11-30","objectID":"/vscode/:1:0","tags":["vscode"],"title":"Visual Studio Code 使用手册","uri":"/vscode/"},{"categories":["manual"],"content":"设置中文 1）在插件商店下载插件 Chinese (Simplified) Language Pack for Visual Studio Code，install and reload 2）【Ctrl + Shift + p】搜索 configure display language，打开 locale.json 文件 3）修改 locale.json 文件，“locale”:“zh-cn” 4）重启 vscode ","date":"2018-11-30","objectID":"/vscode/:1:1","tags":["vscode"],"title":"Visual Studio Code 使用手册","uri":"/vscode/"},{"categories":["manual"],"content":"vscode 设置同步 下载插件 Settings Sync 并安装重载 上传配置 从 GitHub 上获取 Personal Access Token Settings / Developer settings / Personal access tokens / Generate New Token 获取 access tokens 保存 Token 以备使用（从其他计算机上传配置需要） 第一次上传配置 在控制面板中输入 “Sync : Upload” 快捷键 Shift + Alt + u 这会自动打开你的 GitHub Settings 界面，允许你为应用程序生成新的 token，这个token 允许这个插件生成 gist 输入 GitHub Token 插件会自动上传配置并提供 GIST ID 保持 Gist ID 以便在其他计算机下载我们上传的配置 需要 Gist ID 才能访问你使用 GitHub Token 上传的数据。复制此 Gist ID 以便其他计算机可以下载设置。 执行 upload 命令的完整过程 ","date":"2018-11-30","objectID":"/vscode/:1:2","tags":["vscode"],"title":"Visual Studio Code 使用手册","uri":"/vscode/"},{"categories":["manual"],"content":"下载配置 在控制面板输入 “Sync : Download”，程序会请求你的 GitHub Gist ID 快捷键 Shift + Alt + d 输入 GitHub Token 输入 Gist ID，下载上传过的配置 配置下载完成，重新启动 VSCode 以使用已安装的插件 执行 download 命令的完整过程 ","date":"2018-11-30","objectID":"/vscode/:1:3","tags":["vscode"],"title":"Visual Studio Code 使用手册","uri":"/vscode/"},{"categories":["manual"],"content":"重置 Token / GIST Settings 在控制面板输入 Sync : Rest 重置设置 ","date":"2018-11-30","objectID":"/vscode/:1:4","tags":["vscode"],"title":"Visual Studio Code 使用手册","uri":"/vscode/"},{"categories":["manual"],"content":"高级选项 控制面板输入 Sync : Advanced 可以查看更多高级选项 GitHub Token: d2a4cf35819d8b15da88f2eb0576d65443c7d087 GitHub Gist ID: ac136f45652095a7a423e151811fb16e ","date":"2018-11-30","objectID":"/vscode/:1:5","tags":["vscode"],"title":"Visual Studio Code 使用手册","uri":"/vscode/"},{"categories":["skynet"],"content":"skynet ","date":"2017-09-18","objectID":"/skynet/:1:0","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["skynet"],"content":"skynet 核心层 skynet 的核心层分为 service, socket, timer, monitor 四个模块 service 实现了 actor 模型，是最重要的一个模块。其又依赖 handle, mq, module 三个模块。 handle 管理 actor 的生命周期，采用了一种常用的 id 映射和引用计数手法，好处在于可以用 handle 检测对象是否有效。 mq 是消息队列和服务队列的常规实现，用自旋锁保证线程安全。 module 是动态库加载，因为 skynet 约定用动态库来承载服务。 服务的调度是基于多线程的，比例为 m:n，每个服务只能被一个线程持有 socket 实现了一个线程安全的 proactor 模式，之所以放在核心层是为了避免调度的开销。 timer 时间轮算法的计时器，放在核心层同 socket。 monitor 提供了死循环，消息录像，消息处理开销三种监测。 ","date":"2017-09-18","objectID":"/skynet/:1:1","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["skynet"],"content":"lua 支持 好处： 动态语言的便捷和安全 用 lua 的协程可以消除异步回调的分隔 skynet 核心是以动态库为承载的，所以要支持 lua 必须要做两件事： 提供一个 c 服务来做 lua 的宿主 将核心层的外部接口封装为 lua 库 snlua 是宿主，lua-skynet.c 是 lua 库 ","date":"2017-09-18","objectID":"/skynet/:1:2","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["skynet"],"content":"skynet 的运行流程 /skynet-src/skynet_main.c 加载配置文件，嵌入 lua 代码，是为了方便，在 lua 层解析比用 c api 方便。 /skynet-src/skynet_start.c 初始化子模块，创建工作线程。 创建日志服务，bootstrap 服务。 ","date":"2017-09-18","objectID":"/skynet/:1:3","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["skynet"],"content":"参考 skynet GitHub skynet wiki 云风 blog ","date":"2017-09-18","objectID":"/skynet/:2:0","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["skynet"],"content":"记录 基于 skynet 的 MMO 服务器设计 IDE 不是程序员的唯一选择（一） IDE 不是程序员的唯一选择（二） IDE 不是程序员的唯一选择（三） IDE 不是程序员的唯一选择（四） IDE 不是程序员的唯一选择（五） IDE 不是程序员的唯一选择（终） skynet 框架应用 skynet 源码赏析 skynet 服务的本质和缺陷 ","date":"2017-09-18","objectID":"/skynet/:2:1","tags":["skynet"],"title":"skynet 阅读笔记","uri":"/skynet/"},{"categories":["Lua"],"content":"Lua tabel 与元表 ","date":"2017-09-18","objectID":"/lua_table/:1:0","tags":["Lua"],"title":"Lua table","uri":"/lua_table/"},{"categories":["Lua"],"content":"table 常用函数 -- 获取参数表 table，并对这个 table 预定义一个字段 n（表示该表的长度）。 local arg = table.pack(...) for i = 1, arg.n do print(i, arg[i]) end --[[ 提供一个列表，其所有元素都是字符串或数字，返回字符串 list[i]..sep..list[i+1] ··· sep..list[j]。 sep 的默认值是空串， i 的默认值是 1 ， j 的默认值是 #list 。 如果 i 比 j 大，返回空串。 ]] table.concat(list [, sep [, i [, j]]]) --[[ 在 list 的位置 pos 处插入元素 value ， 并后移元素 list[pos], list[pos+1], ···, list[#list] 。 pos 的默认值为 #list+1 ， 因此调用 table.insert(t,x) 会将 x 插在列表 t 的末尾。 ]] table.insert(list, [pos,] value) --[[ 将元素从表 a1 移到表 a2。 这个函数做了次等价于后面这个多重赋值的等价操作： a2[t],··· = a1[f],···,a1[e]。 a2 的默认值为 a1。 目标区间可以和源区间重叠。 索引 f 必须是正数。 ]] table.move(a1, f, e, t [, a2]) --[[ 移除 list 中 pos 位置上的元素，并返回这个被移除的值。 当 pos 是在 1 到 #list 之间的整数时， 它向前移动元素　list[pos+1], list[pos+2], ···, list[#list] 并删除元素 list[#list]； 索引 pos 可以是 #list + 1 ，或在 #list 为 0 时可以是 0 ； 在这些情况下，函数删除元素 list[pos]。 pos 默认为 #list， 因此调用 table.remove(l) 将移除表 l 的最后一个元素。 ]] table.remove(list [, pos]) --[[ 在表内从 list[1] 到 list[#list] 原地 对其间元素按指定次序排序。 如果提供了 comp ， 它必须是一个可以接收两个列表内元素为参数的函数。 当第一个元素需要排在第二个元素之前时，返回真 （因此 not comp(list[i+1],list[i]) 在排序结束后将为真）。 如果没有提供 comp， 将使用标准 Lua 操作 \u003c 作为替代品。 排序算法并不稳定； 即当两个元素次序相等时，它们在排序后的相对位置可能会改变。 ]] table.sort(list [, comp]) --[[ 返回列表中的元素。 这个函数等价于 return list[i], list[i+1], ···, list[j] i 默认为 1 ，j 默认为 #list。 ]] table.unpack(list [, i [, j]]) table 的深拷贝 --[[ 一般表的复制都是引用，深拷贝需要实现：1、值的复制，2、方法的复制 所以要解决 3 个问题： 1、table 存在循环引用 2、metatable（metatable 都不参与复制） 3、keys 也是 table ]] function deepcopy(obj) local Table = {} local function func(obj) if type(obj) ~= \"table\" then return end local newtable = {} Table[obj] = newtable for k, v in pairs(obj) do newtable[func(k)] = func(v) end return setmetatable(newtable, getmetatable(obj)) end return func(obj) end ","date":"2017-09-18","objectID":"/lua_table/:1:1","tags":["Lua"],"title":"Lua table","uri":"/lua_table/"},{"categories":["Lua"],"content":"元表 ","date":"2017-09-18","objectID":"/lua_table/:1:2","tags":["Lua"],"title":"Lua table","uri":"/lua_table/"},{"categories":["Lua"],"content":"参考链接 lua table 的内部实现 ","date":"2017-09-18","objectID":"/lua_table/:2:0","tags":["Lua"],"title":"Lua table","uri":"/lua_table/"},{"categories":["Lua"],"content":"Lua 面向对象 ","date":"2017-09-16","objectID":"/lua_object_oriented/:1:0","tags":["Lua"],"title":"Lua 面向对象","uri":"/lua_object_oriented/"},{"categories":["Lua"],"content":"隐藏 self 参数 用 lua 进行面向对象的编程 声明方法和调用方法统一用 “:” 属性的定义和调用全部用 “.” 定义的时候冒号默认接收 self 参数，调用的时候默认传递调用者自身作为参数，而点号要显式传递或接收 self 参数。 ","date":"2017-09-16","objectID":"/lua_object_oriented/:2:0","tags":["Lua"],"title":"Lua 面向对象","uri":"/lua_object_oriented/"},{"categories":["Lua"],"content":"一个简单的类 function class(classname, super) local superType = type(super) local cls if superType ~= \"function\" and superType ~= \"table\" then superType = nil super = nil end -- inherited(继承) from Lua Object if super then -- 复制基类方法 cls = {} setmetatable(cls, {__index = super}) cls.super = super else cls = {ctor = function() end} -- 构造函数 end cls.__cname = classname cls.__index = cls function cls.new(...) -- 实例化 local obj_data = {} local cls_name = cls.__cname local instance = setmetatable(obj_data, cls) instance.class = cls instance:ctor(...) return instance end return cls end 在 lua 中不存在类的定义这样的概念，不管是类的定义还是类的实例都是通过 lua table 来模拟的。实现的 lua 面向对象是 prototype（原型）方式的，即类是一个 lua table，这个 table 定义了类的原型，而类的实例是基于这个原型的另一个 lua table。 实现 lua 面向对象可以分解为类的定义和类的实例化两部分。类的定义主要实现继承，让子类拥有父类的方法集；类的实例化需要解决实例对象如何共享类的方法集，但独享自己的成员变量实例。 子类在定义时复制所有基类的方法，在实例化时将该类作为 metatable 的 __index 赋值给实例。 ","date":"2017-09-16","objectID":"/lua_object_oriented/:3:0","tags":["Lua"],"title":"Lua 面向对象","uri":"/lua_object_oriented/"},{"categories":["manual"],"content":"什么是 Git？ Git 是分布式版本控制系统 ","date":"2017-08-24","objectID":"/git/:1:0","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"SVN 和 Git SVN 是集中式版本控制系统，版本库集中在中央服务器，在个人电脑上从中央服务器 Update 得到最新的版本，在完成工作后，再 commit 到中央服务器。集中式版本控制系统必须联网才能工作，不管是互联网还是局域网。 Git 是分布式版本控制系统，没有中央处理器，个人的电脑就是一个完整的版本库，工作不需要联网。多人各自在自己电脑上对文件进行修改，再将各自的修改推送给他人，这样就可以相互看到别人的修改。 ","date":"2017-08-24","objectID":"/git/:2:0","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"安装 Git 下载地址：Git 如果要修改安装位置，请放在纯英文路径下， 安装完成后在 Terminal 输入 git 出现提示说明安装成功。 点击鼠标右键，选择 Git Bash here ，就可以使用 Git 命令行工具，Git Bash 使用的是 MinGW。 ","date":"2017-08-24","objectID":"/git/:3:0","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"Git 的基本使用 ","date":"2017-08-24","objectID":"/git/:4:0","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"配置 Git 本地创建 shh key： $ ssh-keygen -t rsa -C “18819457397@163.com” // 邮箱是你在 GitHub 上注册的邮箱 回车之后会要求确认路径和输入密码，使用默认的一路回车即可。 成功之后会在 C:\\Users\\Administrator 下生成 .ssh 文件夹，打开文件夹下的 id_rsa.pub 文件，复制里面的 key。 回到 Github 主页，进入 Setting，左边选择 SSH and GPG keys，New SSH Key，Title 随便填，将刚才复制的 key 粘贴到 Key 里，点击 Add SHH Key 完成。 验证连接是否成功，在 Git bash 下输入： $ ssh -T git@github.com 第一次输入会提示是否 continue，输入 yes 会看到： 表示已经成功连接 github。 设置 username 和 Email，github 每次 commit 都会记录它们。 $ git config –global user.name “bqwhnn” $ git config –global user.email “18819457397@163.com” 注意：git config –global 参数，表示你在这台机器上的所有 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和邮箱。 添加远程地址，将仓库连接到远程服务器 $ git remote add origin https://github.com/bqwhnn/bqwhnn.github.io.git // bqwhnn 是 github 的用户名，bqwhnn.github.io 是新建的仓库 进入 .git，打开 config，可以直接修改内容配置远程地址 ","date":"2017-08-24","objectID":"/git/:4:1","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"Git 操作 版本库 版本库又名仓库，英文名为 repository，这个仓库（目录）里的所有文件都可以被 Git 管理起来，Git 能追踪每个文件的修改和删除，Git 在任何时刻都能追踪历史，也可以在将来某个时刻将文件“还原”。 创建本地仓库 $ mkdir XXXX // 创建文件夹 $ pwd // 显示当前目录 $ git init // 将当前目录变成 git 可以管理的仓库 当前目录下会多出一个 .git 的目录，是 Git 来跟踪管理版本的。 创建远端服务器仓库的克隆版本 $ git clone https://github.com/bqwhnn/bqwhnn.github.io.git 工作流 本地仓库由 Git 维护的**三棵“树”**组成。工作目录：持有实际文件；暂存区（Index）：临时保存改动；HEAD：指向最后一次提交的结果。 Git 基本工作流程第一步，将改动添加到暂存区： $ git add $ git add * $ git add . $ git status // 提交文件前查看改动状态 第二歩，实际提交改动到 HEAD，还未到远程仓库 $ git commit -m “代码提交信息” ","date":"2017-08-24","objectID":"/git/:4:2","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"推送改动 第三步，将本地仓库的 HEAD 中的改动提交到远端仓库 $ git push origin master // master 可以改为想要推送的任何分支 如果还没有克隆现有仓库，又想将仓库连接到某个远程服务器并推送改动： $ git remote add origin 分支 分支是用来将特性开发绝缘开来的。创建仓库时，master 是“默认的”主分支，在其他分支上开发完成后，可以将它们合并到主分支。 $ git checkout -b XXXXX // 创建分支 $ git checkout master // 切换回主分支 $ git branch -d XXXXX // 删除分支 $ git push origin // 将分支推送到远端仓库 更新和合并 $ git pull [origin master] // 更新本地仓库至最新改动 在你的工作目录中*获取（fetch）并合并（merge）*远端的改动 $ git merge // 合并其他分支到当前分支 Git 在尝试自动合并改动时并非每次都成功，可能出现冲突（conflicts）。 这时需要修改这些文件来手动合并冲突（conflicts），改完之后执行命令将它们标记为合并成功。 $ git add $ git diff \u003csource_branch\u003e \u003ctarget_branch\u003e 合并改动之前，可以用 diff 命令预览差异 标签 为软件发布创建标签是推荐的 $ git tag 1.0.0 1b2e1d63ff // 创建名为 1.0.0 的标签，后面是 ID 前几位 $ git log // 获取提交 ID 替换本地改动 git checkout – 使用 HEAD 中的最新内容替换工作目录文件，已添加到暂存区的改动和新文件不会受到影响。 $ git fetch origin $ git reset –hard origin/master 丢弃本地的所有改动和提交，到远程服务器获取最新的版本历史，并将本地分支指向它。 ","date":"2017-08-24","objectID":"/git/:4:3","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"参考 常用 Git 命令清单 Git 工作流程 Github 简明教程 git - 简明指南 ","date":"2017-08-24","objectID":"/git/:5:0","tags":["Git"],"title":"Git 使用教程","uri":"/git/"},{"categories":["manual"],"content":"使用 github pages 首先在 github 中建立一个基于自己用户名的 repository：比如我建立一个名为 bqwhnn.github.io 的 repo。 系统在检测到这样格式的 repo 文件名后，会在 setting 中自动开启 GitHub Pages 功能。之后可以将这个 repo clone 到本地进行修改，在里面上传的网页就是你的网站的内容。 ","date":"2017-08-24","objectID":"/jekyll_github_page/:1:0","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"部署 jekyll ","date":"2017-08-24","objectID":"/jekyll_github_page/:2:0","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"前置：Ruby Mac 和 Linux 可以用 Terminal 配合 yum 或者 brew 这样的包管理器来安装 ruby，Windows 下可以更方便地使用集成好的 RubyInstaller 进行安装。 ","date":"2017-08-24","objectID":"/jekyll_github_page/:2:1","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"RubyGems gem 是一个 ruby 的包管理系统，使用 gem 可以方便的在本地安装 ruby 应用。 安装方法 // 在 RubyGems 官网下载压缩包，解压到本地任意位置 // 在 Terminal 中输入 $ cd your path to RubyGems // 解压位置 $ ruby setup.rb ","date":"2017-08-24","objectID":"/jekyll_github_page/:2:2","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"安装 jekyll 类似 nodejs 和 npm 的包安装，使用 gem 安装 jekyll，直接在 Terminal 中输入： $ gem install bundler // 先安装依赖包 bundler $ gem install jekyll jekyll 模板网站：Jekyll Themes 使用模板可能会缺少东西，看错误提示缺什么直接 $ gem install XXXX ","date":"2017-08-24","objectID":"/jekyll_github_page/:2:3","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"网站预览 $ cd your website path $ jekyll serve // 一个开发服务器将会运行在 http://localhost:4000/ // 在浏览器输入网址就可以在本地服务器看到网站 ","date":"2017-08-24","objectID":"/jekyll_github_page/:2:4","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"},{"categories":["manual"],"content":"参考 github上利用jekyll搭建自己的blog的操作顺序？ jekyll博客搭建之艰辛之路 ","date":"2017-08-24","objectID":"/jekyll_github_page/:3:0","tags":["Jekyll","GitHub"],"title":"Jekyll + GitHub Pages 搭建博客流程","uri":"/jekyll_github_page/"}]